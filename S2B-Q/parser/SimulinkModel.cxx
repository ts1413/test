// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SimulinkModel.hxx"

namespace SimulinkModel
{
  namespace XSD
  {
    // blocks_T
    // 

    const blocks_T::file_sequence& blocks_T::
    file () const
    {
      return this->file_;
    }

    blocks_T::file_sequence& blocks_T::
    file ()
    {
      return this->file_;
    }

    void blocks_T::
    file (const file_sequence& s)
    {
      this->file_ = s;
    }

    const blocks_T::shim_params_sequence& blocks_T::
    shim_params () const
    {
      return this->shim_params_;
    }

    blocks_T::shim_params_sequence& blocks_T::
    shim_params ()
    {
      return this->shim_params_;
    }

    void blocks_T::
    shim_params (const shim_params_sequence& s)
    {
      this->shim_params_ = s;
    }

    const blocks_T::block_sequence& blocks_T::
    block () const
    {
      return this->block_;
    }

    blocks_T::block_sequence& blocks_T::
    block ()
    {
      return this->block_;
    }

    void blocks_T::
    block (const block_sequence& s)
    {
      this->block_ = s;
    }

    const blocks_T::code_sequence& blocks_T::
    code () const
    {
      return this->code_;
    }

    blocks_T::code_sequence& blocks_T::
    code ()
    {
      return this->code_;
    }

    void blocks_T::
    code (const code_sequence& s)
    {
      this->code_ = s;
    }

    const blocks_T::object_sequence& blocks_T::
    object () const
    {
      return this->object_;
    }

    blocks_T::object_sequence& blocks_T::
    object ()
    {
      return this->object_;
    }

    void blocks_T::
    object (const object_sequence& s)
    {
      this->object_ = s;
    }

    const blocks_T::deftype_sequence& blocks_T::
    deftype () const
    {
      return this->deftype_;
    }

    blocks_T::deftype_sequence& blocks_T::
    deftype ()
    {
      return this->deftype_;
    }

    void blocks_T::
    deftype (const deftype_sequence& s)
    {
      this->deftype_ = s;
    }

    const blocks_T::includes_sequence& blocks_T::
    includes () const
    {
      return this->includes_;
    }

    blocks_T::includes_sequence& blocks_T::
    includes ()
    {
      return this->includes_;
    }

    void blocks_T::
    includes (const includes_sequence& s)
    {
      this->includes_ = s;
    }

    const blocks_T::function_sequence& blocks_T::
    function () const
    {
      return this->function_;
    }

    blocks_T::function_sequence& blocks_T::
    function ()
    {
      return this->function_;
    }

    void blocks_T::
    function (const function_sequence& s)
    {
      this->function_ = s;
    }

    const blocks_T::name_optional& blocks_T::
    name () const
    {
      return this->name_;
    }

    blocks_T::name_optional& blocks_T::
    name ()
    {
      return this->name_;
    }

    void blocks_T::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void blocks_T::
    name (const name_optional& x)
    {
      this->name_ = x;
    }

    void blocks_T::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }


    // file_T
    // 

    const file_T::type_type& file_T::
    type () const
    {
      return this->type_.get ();
    }

    file_T::type_type& file_T::
    type ()
    {
      return this->type_.get ();
    }

    void file_T::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void file_T::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const file_T::name_type& file_T::
    name () const
    {
      return this->name_.get ();
    }

    file_T::name_type& file_T::
    name ()
    {
      return this->name_.get ();
    }

    void file_T::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void file_T::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const file_T::timestamp_type& file_T::
    timestamp () const
    {
      return this->timestamp_.get ();
    }

    file_T::timestamp_type& file_T::
    timestamp ()
    {
      return this->timestamp_.get ();
    }

    void file_T::
    timestamp (const timestamp_type& x)
    {
      this->timestamp_.set (x);
    }

    void file_T::
    timestamp (::std::auto_ptr< timestamp_type > x)
    {
      this->timestamp_.set (x);
    }

    const file_T::size_type& file_T::
    size () const
    {
      return this->size_.get ();
    }

    file_T::size_type& file_T::
    size ()
    {
      return this->size_.get ();
    }

    void file_T::
    size (const size_type& x)
    {
      this->size_.set (x);
    }


    // shim_params_T
    // 

    const shim_params_T::element_type& shim_params_T::
    element () const
    {
      return this->element_.get ();
    }

    shim_params_T::element_type& shim_params_T::
    element ()
    {
      return this->element_.get ();
    }

    void shim_params_T::
    element (const element_type& x)
    {
      this->element_.set (x);
    }

    void shim_params_T::
    element (::std::auto_ptr< element_type > x)
    {
      this->element_.set (x);
    }

    const shim_params_T::name_type& shim_params_T::
    name () const
    {
      return this->name_.get ();
    }

    shim_params_T::name_type& shim_params_T::
    name ()
    {
      return this->name_.get ();
    }

    void shim_params_T::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void shim_params_T::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }


    // block_T
    // 

    const block_T::input_sequence& block_T::
    input () const
    {
      return this->input_;
    }

    block_T::input_sequence& block_T::
    input ()
    {
      return this->input_;
    }

    void block_T::
    input (const input_sequence& s)
    {
      this->input_ = s;
    }

    const block_T::output_sequence& block_T::
    output () const
    {
      return this->output_;
    }

    block_T::output_sequence& block_T::
    output ()
    {
      return this->output_;
    }

    void block_T::
    output (const output_sequence& s)
    {
      this->output_ = s;
    }

    const block_T::blocks_sequence& block_T::
    blocks () const
    {
      return this->blocks_;
    }

    block_T::blocks_sequence& block_T::
    blocks ()
    {
      return this->blocks_;
    }

    void block_T::
    blocks (const blocks_sequence& s)
    {
      this->blocks_ = s;
    }

    const block_T::var_sequence& block_T::
    var () const
    {
      return this->var_;
    }

    block_T::var_sequence& block_T::
    var ()
    {
      return this->var_;
    }

    void block_T::
    var (const var_sequence& s)
    {
      this->var_ = s;
    }

    const block_T::signal_sequence& block_T::
    signal () const
    {
      return this->signal_;
    }

    block_T::signal_sequence& block_T::
    signal ()
    {
      return this->signal_;
    }

    void block_T::
    signal (const signal_sequence& s)
    {
      this->signal_ = s;
    }

    const block_T::state_sequence& block_T::
    state () const
    {
      return this->state_;
    }

    block_T::state_sequence& block_T::
    state ()
    {
      return this->state_;
    }

    void block_T::
    state (const state_sequence& s)
    {
      this->state_ = s;
    }

    const block_T::trigger_state_sequence& block_T::
    trigger_state () const
    {
      return this->trigger_state_;
    }

    block_T::trigger_state_sequence& block_T::
    trigger_state ()
    {
      return this->trigger_state_;
    }

    void block_T::
    trigger_state (const trigger_state_sequence& s)
    {
      this->trigger_state_ = s;
    }

    const block_T::invariant_signal_sequence& block_T::
    invariant_signal () const
    {
      return this->invariant_signal_;
    }

    block_T::invariant_signal_sequence& block_T::
    invariant_signal ()
    {
      return this->invariant_signal_;
    }

    void block_T::
    invariant_signal (const invariant_signal_sequence& s)
    {
      this->invariant_signal_ = s;
    }

    const block_T::param_sequence& block_T::
    param () const
    {
      return this->param_;
    }

    block_T::param_sequence& block_T::
    param ()
    {
      return this->param_;
    }

    void block_T::
    param (const param_sequence& s)
    {
      this->param_ = s;
    }

    const block_T::const_param_sequence& block_T::
    const_param () const
    {
      return this->const_param_;
    }

    block_T::const_param_sequence& block_T::
    const_param ()
    {
      return this->const_param_;
    }

    void block_T::
    const_param (const const_param_sequence& s)
    {
      this->const_param_ = s;
    }

    const block_T::code_sequence& block_T::
    code () const
    {
      return this->code_;
    }

    block_T::code_sequence& block_T::
    code ()
    {
      return this->code_;
    }

    void block_T::
    code (const code_sequence& s)
    {
      this->code_ = s;
    }

    const block_T::performance_sequence& block_T::
    performance () const
    {
      return this->performance_;
    }

    block_T::performance_sequence& block_T::
    performance ()
    {
      return this->performance_;
    }

    void block_T::
    performance (const performance_sequence& s)
    {
      this->performance_ = s;
    }

    const block_T::forward_sequence& block_T::
    forward () const
    {
      return this->forward_;
    }

    block_T::forward_sequence& block_T::
    forward ()
    {
      return this->forward_;
    }

    void block_T::
    forward (const forward_sequence& s)
    {
      this->forward_ = s;
    }

    const block_T::backword_sequence& block_T::
    backword () const
    {
      return this->backword_;
    }

    block_T::backword_sequence& block_T::
    backword ()
    {
      return this->backword_;
    }

    void block_T::
    backword (const backword_sequence& s)
    {
      this->backword_ = s;
    }

    const block_T::merged_to_sequence& block_T::
    merged_to () const
    {
      return this->merged_to_;
    }

    block_T::merged_to_sequence& block_T::
    merged_to ()
    {
      return this->merged_to_;
    }

    void block_T::
    merged_to (const merged_to_sequence& s)
    {
      this->merged_to_ = s;
    }

    const block_T::merge_block_sequence& block_T::
    merge_block () const
    {
      return this->merge_block_;
    }

    block_T::merge_block_sequence& block_T::
    merge_block ()
    {
      return this->merge_block_;
    }

    void block_T::
    merge_block (const merge_block_sequence& s)
    {
      this->merge_block_ = s;
    }

    const block_T::bind_sequence& block_T::
    bind () const
    {
      return this->bind_;
    }

    block_T::bind_sequence& block_T::
    bind ()
    {
      return this->bind_;
    }

    void block_T::
    bind (const bind_sequence& s)
    {
      this->bind_ = s;
    }

    const block_T::bound_to_sequence& block_T::
    bound_to () const
    {
      return this->bound_to_;
    }

    block_T::bound_to_sequence& block_T::
    bound_to ()
    {
      return this->bound_to_;
    }

    void block_T::
    bound_to (const bound_to_sequence& s)
    {
      this->bound_to_ = s;
    }

    const block_T::blocktype_type& block_T::
    blocktype () const
    {
      return this->blocktype_.get ();
    }

    block_T::blocktype_type& block_T::
    blocktype ()
    {
      return this->blocktype_.get ();
    }

    void block_T::
    blocktype (const blocktype_type& x)
    {
      this->blocktype_.set (x);
    }

    void block_T::
    blocktype (::std::auto_ptr< blocktype_type > x)
    {
      this->blocktype_.set (x);
    }

    const block_T::name_type& block_T::
    name () const
    {
      return this->name_.get ();
    }

    block_T::name_type& block_T::
    name ()
    {
      return this->name_.get ();
    }

    void block_T::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void block_T::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const block_T::type_optional& block_T::
    type () const
    {
      return this->type_;
    }

    block_T::type_optional& block_T::
    type ()
    {
      return this->type_;
    }

    void block_T::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void block_T::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    void block_T::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const block_T::rate_optional& block_T::
    rate () const
    {
      return this->rate_;
    }

    block_T::rate_optional& block_T::
    rate ()
    {
      return this->rate_;
    }

    void block_T::
    rate (const rate_type& x)
    {
      this->rate_.set (x);
    }

    void block_T::
    rate (const rate_optional& x)
    {
      this->rate_ = x;
    }

    void block_T::
    rate (::std::auto_ptr< rate_type > x)
    {
      this->rate_.set (x);
    }

    const block_T::Period_optional& block_T::
    Period () const
    {
      return this->Period_;
    }

    block_T::Period_optional& block_T::
    Period ()
    {
      return this->Period_;
    }

    void block_T::
    Period (const Period_type& x)
    {
      this->Period_.set (x);
    }

    void block_T::
    Period (const Period_optional& x)
    {
      this->Period_ = x;
    }

    const block_T::PulseType_optional& block_T::
    PulseType () const
    {
      return this->PulseType_;
    }

    block_T::PulseType_optional& block_T::
    PulseType ()
    {
      return this->PulseType_;
    }

    void block_T::
    PulseType (const PulseType_type& x)
    {
      this->PulseType_.set (x);
    }

    void block_T::
    PulseType (const PulseType_optional& x)
    {
      this->PulseType_ = x;
    }

    void block_T::
    PulseType (::std::auto_ptr< PulseType_type > x)
    {
      this->PulseType_.set (x);
    }

    const block_T::PulseWidth_optional& block_T::
    PulseWidth () const
    {
      return this->PulseWidth_;
    }

    block_T::PulseWidth_optional& block_T::
    PulseWidth ()
    {
      return this->PulseWidth_;
    }

    void block_T::
    PulseWidth (const PulseWidth_type& x)
    {
      this->PulseWidth_.set (x);
    }

    void block_T::
    PulseWidth (const PulseWidth_optional& x)
    {
      this->PulseWidth_ = x;
    }

    const block_T::peinfo_optional& block_T::
    peinfo () const
    {
      return this->peinfo_;
    }

    block_T::peinfo_optional& block_T::
    peinfo ()
    {
      return this->peinfo_;
    }

    void block_T::
    peinfo (const peinfo_type& x)
    {
      this->peinfo_.set (x);
    }

    void block_T::
    peinfo (const peinfo_optional& x)
    {
      this->peinfo_ = x;
    }

    void block_T::
    peinfo (::std::auto_ptr< peinfo_type > x)
    {
      this->peinfo_.set (x);
    }

    const block_T::id_optional& block_T::
    id () const
    {
      return this->id_;
    }

    block_T::id_optional& block_T::
    id ()
    {
      return this->id_;
    }

    void block_T::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void block_T::
    id (const id_optional& x)
    {
      this->id_ = x;
    }

    const block_T::priority_optional& block_T::
    priority () const
    {
      return this->priority_;
    }

    block_T::priority_optional& block_T::
    priority ()
    {
      return this->priority_;
    }

    void block_T::
    priority (const priority_type& x)
    {
      this->priority_.set (x);
    }

    void block_T::
    priority (const priority_optional& x)
    {
      this->priority_ = x;
    }

    const block_T::sequence_optional& block_T::
    sequence () const
    {
      return this->sequence_;
    }

    block_T::sequence_optional& block_T::
    sequence ()
    {
      return this->sequence_;
    }

    void block_T::
    sequence (const sequence_type& x)
    {
      this->sequence_.set (x);
    }

    void block_T::
    sequence (const sequence_optional& x)
    {
      this->sequence_ = x;
    }

    const block_T::stateflow_optional& block_T::
    stateflow () const
    {
      return this->stateflow_;
    }

    block_T::stateflow_optional& block_T::
    stateflow ()
    {
      return this->stateflow_;
    }

    void block_T::
    stateflow (const stateflow_type& x)
    {
      this->stateflow_.set (x);
    }

    void block_T::
    stateflow (const stateflow_optional& x)
    {
      this->stateflow_ = x;
    }

    void block_T::
    stateflow (::std::auto_ptr< stateflow_type > x)
    {
      this->stateflow_.set (x);
    }

    const block_T::DataStoreName_optional& block_T::
    DataStoreName () const
    {
      return this->DataStoreName_;
    }

    block_T::DataStoreName_optional& block_T::
    DataStoreName ()
    {
      return this->DataStoreName_;
    }

    void block_T::
    DataStoreName (const DataStoreName_type& x)
    {
      this->DataStoreName_.set (x);
    }

    void block_T::
    DataStoreName (const DataStoreName_optional& x)
    {
      this->DataStoreName_ = x;
    }

    void block_T::
    DataStoreName (::std::auto_ptr< DataStoreName_type > x)
    {
      this->DataStoreName_.set (x);
    }

    const block_T::TreatAsAtomicUnit_optional& block_T::
    TreatAsAtomicUnit () const
    {
      return this->TreatAsAtomicUnit_;
    }

    block_T::TreatAsAtomicUnit_optional& block_T::
    TreatAsAtomicUnit ()
    {
      return this->TreatAsAtomicUnit_;
    }

    void block_T::
    TreatAsAtomicUnit (const TreatAsAtomicUnit_type& x)
    {
      this->TreatAsAtomicUnit_.set (x);
    }

    void block_T::
    TreatAsAtomicUnit (const TreatAsAtomicUnit_optional& x)
    {
      this->TreatAsAtomicUnit_ = x;
    }

    void block_T::
    TreatAsAtomicUnit (::std::auto_ptr< TreatAsAtomicUnit_type > x)
    {
      this->TreatAsAtomicUnit_.set (x);
    }

    const block_T::SampleTimeType_optional& block_T::
    SampleTimeType () const
    {
      return this->SampleTimeType_;
    }

    block_T::SampleTimeType_optional& block_T::
    SampleTimeType ()
    {
      return this->SampleTimeType_;
    }

    void block_T::
    SampleTimeType (const SampleTimeType_type& x)
    {
      this->SampleTimeType_.set (x);
    }

    void block_T::
    SampleTimeType (const SampleTimeType_optional& x)
    {
      this->SampleTimeType_ = x;
    }

    void block_T::
    SampleTimeType (::std::auto_ptr< SampleTimeType_type > x)
    {
      this->SampleTimeType_.set (x);
    }

    const block_T::TriggerType_optional& block_T::
    TriggerType () const
    {
      return this->TriggerType_;
    }

    block_T::TriggerType_optional& block_T::
    TriggerType ()
    {
      return this->TriggerType_;
    }

    void block_T::
    TriggerType (const TriggerType_type& x)
    {
      this->TriggerType_.set (x);
    }

    void block_T::
    TriggerType (const TriggerType_optional& x)
    {
      this->TriggerType_ = x;
    }

    void block_T::
    TriggerType (::std::auto_ptr< TriggerType_type > x)
    {
      this->TriggerType_.set (x);
    }

    const block_T::TriggerSignalSampleTime_optional& block_T::
    TriggerSignalSampleTime () const
    {
      return this->TriggerSignalSampleTime_;
    }

    block_T::TriggerSignalSampleTime_optional& block_T::
    TriggerSignalSampleTime ()
    {
      return this->TriggerSignalSampleTime_;
    }

    void block_T::
    TriggerSignalSampleTime (const TriggerSignalSampleTime_type& x)
    {
      this->TriggerSignalSampleTime_.set (x);
    }

    void block_T::
    TriggerSignalSampleTime (const TriggerSignalSampleTime_optional& x)
    {
      this->TriggerSignalSampleTime_ = x;
    }

    void block_T::
    TriggerSignalSampleTime (::std::auto_ptr< TriggerSignalSampleTime_type > x)
    {
      this->TriggerSignalSampleTime_.set (x);
    }


    // ioport_T
    // 

    const ioport_T::connect_sequence& ioport_T::
    connect () const
    {
      return this->connect_;
    }

    ioport_T::connect_sequence& ioport_T::
    connect ()
    {
      return this->connect_;
    }

    void ioport_T::
    connect (const connect_sequence& s)
    {
      this->connect_ = s;
    }

    const ioport_T::line_type& ioport_T::
    line () const
    {
      return this->line_.get ();
    }

    ioport_T::line_type& ioport_T::
    line ()
    {
      return this->line_.get ();
    }

    void ioport_T::
    line (const line_type& x)
    {
      this->line_.set (x);
    }

    void ioport_T::
    line (::std::auto_ptr< line_type > x)
    {
      this->line_.set (x);
    }

    const ioport_T::port_type& ioport_T::
    port () const
    {
      return this->port_.get ();
    }

    ioport_T::port_type& ioport_T::
    port ()
    {
      return this->port_.get ();
    }

    void ioport_T::
    port (const port_type& x)
    {
      this->port_.set (x);
    }

    void ioport_T::
    port (::std::auto_ptr< port_type > x)
    {
      this->port_.set (x);
    }

    const ioport_T::type_optional& ioport_T::
    type () const
    {
      return this->type_;
    }

    ioport_T::type_optional& ioport_T::
    type ()
    {
      return this->type_;
    }

    void ioport_T::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void ioport_T::
    type (const type_optional& x)
    {
      this->type_ = x;
    }

    void ioport_T::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const ioport_T::usename_optional& ioport_T::
    usename () const
    {
      return this->usename_;
    }

    ioport_T::usename_optional& ioport_T::
    usename ()
    {
      return this->usename_;
    }

    void ioport_T::
    usename (const usename_type& x)
    {
      this->usename_.set (x);
    }

    void ioport_T::
    usename (const usename_optional& x)
    {
      this->usename_ = x;
    }


    // connection_T
    // 

    const connection_T::block_type& connection_T::
    block () const
    {
      return this->block_.get ();
    }

    connection_T::block_type& connection_T::
    block ()
    {
      return this->block_.get ();
    }

    void connection_T::
    block (const block_type& x)
    {
      this->block_.set (x);
    }

    void connection_T::
    block (::std::auto_ptr< block_type > x)
    {
      this->block_.set (x);
    }

    const connection_T::port_type& connection_T::
    port () const
    {
      return this->port_.get ();
    }

    connection_T::port_type& connection_T::
    port ()
    {
      return this->port_.get ();
    }

    void connection_T::
    port (const port_type& x)
    {
      this->port_.set (x);
    }

    void connection_T::
    port (::std::auto_ptr< port_type > x)
    {
      this->port_.set (x);
    }


    // var_T
    // 

    const var_T::storage_optional& var_T::
    storage () const
    {
      return this->storage_;
    }

    var_T::storage_optional& var_T::
    storage ()
    {
      return this->storage_;
    }

    void var_T::
    storage (const storage_type& x)
    {
      this->storage_.set (x);
    }

    void var_T::
    storage (const storage_optional& x)
    {
      this->storage_ = x;
    }

    void var_T::
    storage (::std::auto_ptr< storage_type > x)
    {
      this->storage_.set (x);
    }

    const var_T::name_type& var_T::
    name () const
    {
      return this->name_.get ();
    }

    var_T::name_type& var_T::
    name ()
    {
      return this->name_.get ();
    }

    void var_T::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void var_T::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const var_T::type_type& var_T::
    type () const
    {
      return this->type_.get ();
    }

    var_T::type_type& var_T::
    type ()
    {
      return this->type_.get ();
    }

    void var_T::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void var_T::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const var_T::mode_type& var_T::
    mode () const
    {
      return this->mode_.get ();
    }

    var_T::mode_type& var_T::
    mode ()
    {
      return this->mode_.get ();
    }

    void var_T::
    mode (const mode_type& x)
    {
      this->mode_.set (x);
    }

    void var_T::
    mode (::std::auto_ptr< mode_type > x)
    {
      this->mode_.set (x);
    }

    const var_T::line_optional& var_T::
    line () const
    {
      return this->line_;
    }

    var_T::line_optional& var_T::
    line ()
    {
      return this->line_;
    }

    void var_T::
    line (const line_type& x)
    {
      this->line_.set (x);
    }

    void var_T::
    line (const line_optional& x)
    {
      this->line_ = x;
    }

    void var_T::
    line (::std::auto_ptr< line_type > x)
    {
      this->line_.set (x);
    }

    const var_T::port_optional& var_T::
    port () const
    {
      return this->port_;
    }

    var_T::port_optional& var_T::
    port ()
    {
      return this->port_;
    }

    void var_T::
    port (const port_type& x)
    {
      this->port_.set (x);
    }

    void var_T::
    port (const port_optional& x)
    {
      this->port_ = x;
    }

    void var_T::
    port (::std::auto_ptr< port_type > x)
    {
      this->port_.set (x);
    }

    const var_T::size_optional& var_T::
    size () const
    {
      return this->size_;
    }

    var_T::size_optional& var_T::
    size ()
    {
      return this->size_;
    }

    void var_T::
    size (const size_type& x)
    {
      this->size_.set (x);
    }

    void var_T::
    size (const size_optional& x)
    {
      this->size_ = x;
    }

    const var_T::start_optional& var_T::
    start () const
    {
      return this->start_;
    }

    var_T::start_optional& var_T::
    start ()
    {
      return this->start_;
    }

    void var_T::
    start (const start_type& x)
    {
      this->start_.set (x);
    }

    void var_T::
    start (const start_optional& x)
    {
      this->start_ = x;
    }

    const var_T::end_optional& var_T::
    end () const
    {
      return this->end_;
    }

    var_T::end_optional& var_T::
    end ()
    {
      return this->end_;
    }

    void var_T::
    end (const end_type& x)
    {
      this->end_.set (x);
    }

    void var_T::
    end (const end_optional& x)
    {
      this->end_ = x;
    }


    // param_T
    // 

    const param_T::storage_type& param_T::
    storage () const
    {
      return this->storage_.get ();
    }

    param_T::storage_type& param_T::
    storage ()
    {
      return this->storage_.get ();
    }

    void param_T::
    storage (const storage_type& x)
    {
      this->storage_.set (x);
    }

    void param_T::
    storage (::std::auto_ptr< storage_type > x)
    {
      this->storage_.set (x);
    }

    const param_T::name_type& param_T::
    name () const
    {
      return this->name_.get ();
    }

    param_T::name_type& param_T::
    name ()
    {
      return this->name_.get ();
    }

    void param_T::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void param_T::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const param_T::type_type& param_T::
    type () const
    {
      return this->type_.get ();
    }

    param_T::type_type& param_T::
    type ()
    {
      return this->type_.get ();
    }

    void param_T::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void param_T::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const param_T::size_optional& param_T::
    size () const
    {
      return this->size_;
    }

    param_T::size_optional& param_T::
    size ()
    {
      return this->size_;
    }

    void param_T::
    size (const size_type& x)
    {
      this->size_.set (x);
    }

    void param_T::
    size (const size_optional& x)
    {
      this->size_ = x;
    }

    const param_T::value_optional& param_T::
    value () const
    {
      return this->value_;
    }

    param_T::value_optional& param_T::
    value ()
    {
      return this->value_;
    }

    void param_T::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void param_T::
    value (const value_optional& x)
    {
      this->value_ = x;
    }

    void param_T::
    value (::std::auto_ptr< value_type > x)
    {
      this->value_.set (x);
    }


    // code_T
    // 

    const code_T::type_type& code_T::
    type () const
    {
      return this->type_.get ();
    }

    code_T::type_type& code_T::
    type ()
    {
      return this->type_.get ();
    }

    void code_T::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void code_T::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const code_T::file_optional& code_T::
    file () const
    {
      return this->file_;
    }

    code_T::file_optional& code_T::
    file ()
    {
      return this->file_;
    }

    void code_T::
    file (const file_type& x)
    {
      this->file_.set (x);
    }

    void code_T::
    file (const file_optional& x)
    {
      this->file_ = x;
    }

    void code_T::
    file (::std::auto_ptr< file_type > x)
    {
      this->file_.set (x);
    }

    const code_T::line_optional& code_T::
    line () const
    {
      return this->line_;
    }

    code_T::line_optional& code_T::
    line ()
    {
      return this->line_;
    }

    void code_T::
    line (const line_type& x)
    {
      this->line_.set (x);
    }

    void code_T::
    line (const line_optional& x)
    {
      this->line_ = x;
    }

    const code_T::index_optional& code_T::
    index () const
    {
      return this->index_;
    }

    code_T::index_optional& code_T::
    index ()
    {
      return this->index_;
    }

    void code_T::
    index (const index_type& x)
    {
      this->index_.set (x);
    }

    void code_T::
    index (const index_optional& x)
    {
      this->index_ = x;
    }


    // performance_T
    // 

    const performance_T::type_type& performance_T::
    type () const
    {
      return this->type_.get ();
    }

    performance_T::type_type& performance_T::
    type ()
    {
      return this->type_.get ();
    }

    void performance_T::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void performance_T::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const performance_T::best_type& performance_T::
    best () const
    {
      return this->best_.get ();
    }

    performance_T::best_type& performance_T::
    best ()
    {
      return this->best_.get ();
    }

    void performance_T::
    best (const best_type& x)
    {
      this->best_.set (x);
    }

    const performance_T::typical_type& performance_T::
    typical () const
    {
      return this->typical_.get ();
    }

    performance_T::typical_type& performance_T::
    typical ()
    {
      return this->typical_.get ();
    }

    void performance_T::
    typical (const typical_type& x)
    {
      this->typical_.set (x);
    }

    const performance_T::worst_type& performance_T::
    worst () const
    {
      return this->worst_.get ();
    }

    performance_T::worst_type& performance_T::
    worst ()
    {
      return this->worst_.get ();
    }

    void performance_T::
    worst (const worst_type& x)
    {
      this->worst_.set (x);
    }


    // link_T
    // 

    const link_T::var_sequence& link_T::
    var () const
    {
      return this->var_;
    }

    link_T::var_sequence& link_T::
    var ()
    {
      return this->var_;
    }

    void link_T::
    var (const var_sequence& s)
    {
      this->var_ = s;
    }

    const link_T::block_type& link_T::
    block () const
    {
      return this->block_.get ();
    }

    link_T::block_type& link_T::
    block ()
    {
      return this->block_.get ();
    }

    void link_T::
    block (const block_type& x)
    {
      this->block_.set (x);
    }

    void link_T::
    block (::std::auto_ptr< block_type > x)
    {
      this->block_.set (x);
    }

    const link_T::type_type& link_T::
    type () const
    {
      return this->type_.get ();
    }

    link_T::type_type& link_T::
    type ()
    {
      return this->type_.get ();
    }

    void link_T::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void link_T::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const link_T::label_optional& link_T::
    label () const
    {
      return this->label_;
    }

    link_T::label_optional& link_T::
    label ()
    {
      return this->label_;
    }

    void link_T::
    label (const label_type& x)
    {
      this->label_.set (x);
    }

    void link_T::
    label (const label_optional& x)
    {
      this->label_ = x;
    }

    void link_T::
    label (::std::auto_ptr< label_type > x)
    {
      this->label_.set (x);
    }


    // object_T
    // 

    const object_T::type_type& object_T::
    type () const
    {
      return this->type_.get ();
    }

    object_T::type_type& object_T::
    type ()
    {
      return this->type_.get ();
    }

    void object_T::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void object_T::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }

    const object_T::has_struct_optional& object_T::
    has_struct () const
    {
      return this->has_struct_;
    }

    object_T::has_struct_optional& object_T::
    has_struct ()
    {
      return this->has_struct_;
    }

    void object_T::
    has_struct (const has_struct_type& x)
    {
      this->has_struct_.set (x);
    }

    void object_T::
    has_struct (const has_struct_optional& x)
    {
      this->has_struct_ = x;
    }

    const object_T::name_type& object_T::
    name () const
    {
      return this->name_.get ();
    }

    object_T::name_type& object_T::
    name ()
    {
      return this->name_.get ();
    }

    void object_T::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void object_T::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const object_T::size_optional& object_T::
    size () const
    {
      return this->size_;
    }

    object_T::size_optional& object_T::
    size ()
    {
      return this->size_;
    }

    void object_T::
    size (const size_type& x)
    {
      this->size_.set (x);
    }

    void object_T::
    size (const size_optional& x)
    {
      this->size_ = x;
    }

    const object_T::value_optional& object_T::
    value () const
    {
      return this->value_;
    }

    object_T::value_optional& object_T::
    value ()
    {
      return this->value_;
    }

    void object_T::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void object_T::
    value (const value_optional& x)
    {
      this->value_ = x;
    }

    void object_T::
    value (::std::auto_ptr< value_type > x)
    {
      this->value_.set (x);
    }

    const object_T::kind_optional& object_T::
    kind () const
    {
      return this->kind_;
    }

    object_T::kind_optional& object_T::
    kind ()
    {
      return this->kind_;
    }

    void object_T::
    kind (const kind_type& x)
    {
      this->kind_.set (x);
    }

    void object_T::
    kind (const kind_optional& x)
    {
      this->kind_ = x;
    }

    void object_T::
    kind (::std::auto_ptr< kind_type > x)
    {
      this->kind_.set (x);
    }


    // include_T
    // 

    const include_T::index_type& include_T::
    index () const
    {
      return this->index_.get ();
    }

    include_T::index_type& include_T::
    index ()
    {
      return this->index_.get ();
    }

    void include_T::
    index (const index_type& x)
    {
      this->index_.set (x);
    }

    const include_T::from_optional& include_T::
    from () const
    {
      return this->from_;
    }

    include_T::from_optional& include_T::
    from ()
    {
      return this->from_;
    }

    void include_T::
    from (const from_type& x)
    {
      this->from_.set (x);
    }

    void include_T::
    from (const from_optional& x)
    {
      this->from_ = x;
    }

    void include_T::
    from (::std::auto_ptr< from_type > x)
    {
      this->from_.set (x);
    }

    const include_T::file_type& include_T::
    file () const
    {
      return this->file_.get ();
    }

    include_T::file_type& include_T::
    file ()
    {
      return this->file_.get ();
    }

    void include_T::
    file (const file_type& x)
    {
      this->file_.set (x);
    }

    void include_T::
    file (::std::auto_ptr< file_type > x)
    {
      this->file_.set (x);
    }


    // function_T
    // 

    const function_T::code_optional& function_T::
    code () const
    {
      return this->code_;
    }

    function_T::code_optional& function_T::
    code ()
    {
      return this->code_;
    }

    void function_T::
    code (const code_type& x)
    {
      this->code_.set (x);
    }

    void function_T::
    code (const code_optional& x)
    {
      this->code_ = x;
    }

    void function_T::
    code (::std::auto_ptr< code_type > x)
    {
      this->code_.set (x);
    }

    const function_T::function_sequence& function_T::
    function () const
    {
      return this->function_;
    }

    function_T::function_sequence& function_T::
    function ()
    {
      return this->function_;
    }

    void function_T::
    function (const function_sequence& s)
    {
      this->function_ = s;
    }

    const function_T::name_type& function_T::
    name () const
    {
      return this->name_.get ();
    }

    function_T::name_type& function_T::
    name ()
    {
      return this->name_.get ();
    }

    void function_T::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void function_T::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }

    const function_T::type_type& function_T::
    type () const
    {
      return this->type_.get ();
    }

    function_T::type_type& function_T::
    type ()
    {
      return this->type_.get ();
    }

    void function_T::
    type (const type_type& x)
    {
      this->type_.set (x);
    }

    void function_T::
    type (::std::auto_ptr< type_type > x)
    {
      this->type_.set (x);
    }


    // block_name_T
    // 

    const block_name_T::block_type& block_name_T::
    block () const
    {
      return this->block_.get ();
    }

    block_name_T::block_type& block_name_T::
    block ()
    {
      return this->block_.get ();
    }

    void block_name_T::
    block (const block_type& x)
    {
      this->block_.set (x);
    }

    void block_name_T::
    block (::std::auto_ptr< block_type > x)
    {
      this->block_.set (x);
    }


    // type
    // 

    type::
    type (value v)
    : ::xml_schema::string (_xsd_type_literals_[v])
    {
    }

    type::
    type (const char* v)
    : ::xml_schema::string (v)
    {
    }

    type::
    type (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    type::
    type (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    type::
    type (const type& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    type& type::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_type_literals_[v]);

      return *this;
    }


    // element
    // 

    element::
    element (value v)
    : ::xml_schema::string (_xsd_element_literals_[v])
    {
    }

    element::
    element (const char* v)
    : ::xml_schema::string (v)
    {
    }

    element::
    element (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    element::
    element (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    element::
    element (const element& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    element& element::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_element_literals_[v]);

      return *this;
    }


    // mode
    // 

    mode::
    mode (value v)
    : ::xml_schema::string (_xsd_mode_literals_[v])
    {
    }

    mode::
    mode (const char* v)
    : ::xml_schema::string (v)
    {
    }

    mode::
    mode (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    mode::
    mode (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    mode::
    mode (const mode& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    mode& mode::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_mode_literals_[v]);

      return *this;
    }


    // type1
    // 

    type1::
    type1 (value v)
    : ::xml_schema::string (_xsd_type1_literals_[v])
    {
    }

    type1::
    type1 (const char* v)
    : ::xml_schema::string (v)
    {
    }

    type1::
    type1 (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    type1::
    type1 (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    type1::
    type1 (const type1& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    type1& type1::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_type1_literals_[v]);

      return *this;
    }


    // type2
    // 

    type2::
    type2 (value v)
    : ::xml_schema::string (_xsd_type2_literals_[v])
    {
    }

    type2::
    type2 (const char* v)
    : ::xml_schema::string (v)
    {
    }

    type2::
    type2 (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    type2::
    type2 (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    type2::
    type2 (const type2& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    type2& type2::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_type2_literals_[v]);

      return *this;
    }


    // type3
    // 

    type3::
    type3 (value v)
    : ::xml_schema::string (_xsd_type3_literals_[v])
    {
    }

    type3::
    type3 (const char* v)
    : ::xml_schema::string (v)
    {
    }

    type3::
    type3 (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    type3::
    type3 (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    type3::
    type3 (const type3& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    type3& type3::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_type3_literals_[v]);

      return *this;
    }


    // kind
    // 

    kind::
    kind (value v)
    : ::xml_schema::string (_xsd_kind_literals_[v])
    {
    }

    kind::
    kind (const char* v)
    : ::xml_schema::string (v)
    {
    }

    kind::
    kind (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    kind::
    kind (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    kind::
    kind (const kind& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    kind& kind::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_kind_literals_[v]);

      return *this;
    }


    // type4
    // 

    type4::
    type4 (value v)
    : ::xml_schema::string (_xsd_type4_literals_[v])
    {
    }

    type4::
    type4 (const char* v)
    : ::xml_schema::string (v)
    {
    }

    type4::
    type4 (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    type4::
    type4 (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    type4::
    type4 (const type4& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    type4& type4::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_type4_literals_[v]);

      return *this;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace SimulinkModel
{
  namespace XSD
  {
    // blocks_T
    //

    blocks_T::
    blocks_T ()
    : ::xml_schema::type (),
      file_ (this),
      shim_params_ (this),
      block_ (this),
      code_ (this),
      object_ (this),
      deftype_ (this),
      includes_ (this),
      function_ (this),
      name_ (this)
    {
    }

    blocks_T::
    blocks_T (const blocks_T& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      file_ (x.file_, f, this),
      shim_params_ (x.shim_params_, f, this),
      block_ (x.block_, f, this),
      code_ (x.code_, f, this),
      object_ (x.object_, f, this),
      deftype_ (x.deftype_, f, this),
      includes_ (x.includes_, f, this),
      function_ (x.function_, f, this),
      name_ (x.name_, f, this)
    {
    }

    blocks_T::
    blocks_T (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      file_ (this),
      shim_params_ (this),
      block_ (this),
      code_ (this),
      object_ (this),
      deftype_ (this),
      includes_ (this),
      function_ (this),
      name_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void blocks_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // file
        //
        if (n.name () == "file" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< file_type > r (
            file_traits::create (i, f, this));

          this->file_.push_back (r);
          continue;
        }

        // shim-params
        //
        if (n.name () == "shim-params" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< shim_params_type > r (
            shim_params_traits::create (i, f, this));

          this->shim_params_.push_back (r);
          continue;
        }

        // block
        //
        if (n.name () == "block" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< block_type > r (
            block_traits::create (i, f, this));

          this->block_.push_back (r);
          continue;
        }

        // code
        //
        if (n.name () == "code" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< code_type > r (
            code_traits::create (i, f, this));

          this->code_.push_back (r);
          continue;
        }

        // object
        //
        if (n.name () == "object" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< object_type > r (
            object_traits::create (i, f, this));

          this->object_.push_back (r);
          continue;
        }

        // deftype
        //
        if (n.name () == "deftype" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< deftype_type > r (
            deftype_traits::create (i, f, this));

          this->deftype_.push_back (r);
          continue;
        }

        // includes
        //
        if (n.name () == "includes" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< includes_type > r (
            includes_traits::create (i, f, this));

          this->includes_.push_back (r);
          continue;
        }

        // function
        //
        if (n.name () == "function" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< function_type > r (
            function_traits::create (i, f, this));

          this->function_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }
      }
    }

    blocks_T* blocks_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class blocks_T (*this, f, c);
    }

    blocks_T& blocks_T::
    operator= (const blocks_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->file_ = x.file_;
        this->shim_params_ = x.shim_params_;
        this->block_ = x.block_;
        this->code_ = x.code_;
        this->object_ = x.object_;
        this->deftype_ = x.deftype_;
        this->includes_ = x.includes_;
        this->function_ = x.function_;
        this->name_ = x.name_;
      }

      return *this;
    }

    blocks_T::
    ~blocks_T ()
    {
    }

    // file_T
    //

    file_T::
    file_T (const type_type& type,
            const name_type& name,
            const timestamp_type& timestamp,
            const size_type& size)
    : ::xml_schema::type (),
      type_ (type, this),
      name_ (name, this),
      timestamp_ (timestamp, this),
      size_ (size, this)
    {
    }

    file_T::
    file_T (const file_T& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      type_ (x.type_, f, this),
      name_ (x.name_, f, this),
      timestamp_ (x.timestamp_, f, this),
      size_ (x.size_, f, this)
    {
    }

    file_T::
    file_T (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      type_ (this),
      name_ (this),
      timestamp_ (this),
      size_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void file_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "timestamp" && n.namespace_ ().empty ())
        {
          this->timestamp_.set (timestamp_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "size" && n.namespace_ ().empty ())
        {
          this->size_.set (size_traits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!timestamp_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "timestamp",
          "");
      }

      if (!size_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "size",
          "");
      }
    }

    file_T* file_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class file_T (*this, f, c);
    }

    file_T& file_T::
    operator= (const file_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->type_ = x.type_;
        this->name_ = x.name_;
        this->timestamp_ = x.timestamp_;
        this->size_ = x.size_;
      }

      return *this;
    }

    file_T::
    ~file_T ()
    {
    }

    // shim_params_T
    //

    shim_params_T::
    shim_params_T (const element_type& element,
                   const name_type& name)
    : ::xml_schema::type (),
      element_ (element, this),
      name_ (name, this)
    {
    }

    shim_params_T::
    shim_params_T (const shim_params_T& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      element_ (x.element_, f, this),
      name_ (x.name_, f, this)
    {
    }

    shim_params_T::
    shim_params_T (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      element_ (this),
      name_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void shim_params_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "element" && n.namespace_ ().empty ())
        {
          this->element_.set (element_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }
      }

      if (!element_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "element",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    shim_params_T* shim_params_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class shim_params_T (*this, f, c);
    }

    shim_params_T& shim_params_T::
    operator= (const shim_params_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->element_ = x.element_;
        this->name_ = x.name_;
      }

      return *this;
    }

    shim_params_T::
    ~shim_params_T ()
    {
    }

    // block_T
    //

    block_T::
    block_T (const blocktype_type& blocktype,
             const name_type& name)
    : ::xml_schema::type (),
      input_ (this),
      output_ (this),
      blocks_ (this),
      var_ (this),
      signal_ (this),
      state_ (this),
      trigger_state_ (this),
      invariant_signal_ (this),
      param_ (this),
      const_param_ (this),
      code_ (this),
      performance_ (this),
      forward_ (this),
      backword_ (this),
      merged_to_ (this),
      merge_block_ (this),
      bind_ (this),
      bound_to_ (this),
      blocktype_ (blocktype, this),
      name_ (name, this),
      type_ (this),
      rate_ (this),
      Period_ (this),
      PulseType_ (this),
      PulseWidth_ (this),
      peinfo_ (this),
      id_ (this),
      priority_ (this),
      sequence_ (this),
      stateflow_ (this),
      DataStoreName_ (this),
      TreatAsAtomicUnit_ (this),
      SampleTimeType_ (this),
      TriggerType_ (this),
      TriggerSignalSampleTime_ (this)
    {
    }

    block_T::
    block_T (const block_T& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      input_ (x.input_, f, this),
      output_ (x.output_, f, this),
      blocks_ (x.blocks_, f, this),
      var_ (x.var_, f, this),
      signal_ (x.signal_, f, this),
      state_ (x.state_, f, this),
      trigger_state_ (x.trigger_state_, f, this),
      invariant_signal_ (x.invariant_signal_, f, this),
      param_ (x.param_, f, this),
      const_param_ (x.const_param_, f, this),
      code_ (x.code_, f, this),
      performance_ (x.performance_, f, this),
      forward_ (x.forward_, f, this),
      backword_ (x.backword_, f, this),
      merged_to_ (x.merged_to_, f, this),
      merge_block_ (x.merge_block_, f, this),
      bind_ (x.bind_, f, this),
      bound_to_ (x.bound_to_, f, this),
      blocktype_ (x.blocktype_, f, this),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      rate_ (x.rate_, f, this),
      Period_ (x.Period_, f, this),
      PulseType_ (x.PulseType_, f, this),
      PulseWidth_ (x.PulseWidth_, f, this),
      peinfo_ (x.peinfo_, f, this),
      id_ (x.id_, f, this),
      priority_ (x.priority_, f, this),
      sequence_ (x.sequence_, f, this),
      stateflow_ (x.stateflow_, f, this),
      DataStoreName_ (x.DataStoreName_, f, this),
      TreatAsAtomicUnit_ (x.TreatAsAtomicUnit_, f, this),
      SampleTimeType_ (x.SampleTimeType_, f, this),
      TriggerType_ (x.TriggerType_, f, this),
      TriggerSignalSampleTime_ (x.TriggerSignalSampleTime_, f, this)
    {
    }

    block_T::
    block_T (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      input_ (this),
      output_ (this),
      blocks_ (this),
      var_ (this),
      signal_ (this),
      state_ (this),
      trigger_state_ (this),
      invariant_signal_ (this),
      param_ (this),
      const_param_ (this),
      code_ (this),
      performance_ (this),
      forward_ (this),
      backword_ (this),
      merged_to_ (this),
      merge_block_ (this),
      bind_ (this),
      bound_to_ (this),
      blocktype_ (this),
      name_ (this),
      type_ (this),
      rate_ (this),
      Period_ (this),
      PulseType_ (this),
      PulseWidth_ (this),
      peinfo_ (this),
      id_ (this),
      priority_ (this),
      sequence_ (this),
      stateflow_ (this),
      DataStoreName_ (this),
      TreatAsAtomicUnit_ (this),
      SampleTimeType_ (this),
      TriggerType_ (this),
      TriggerSignalSampleTime_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void block_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // input
        //
        if (n.name () == "input" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< input_type > r (
            input_traits::create (i, f, this));

          this->input_.push_back (r);
          continue;
        }

        // output
        //
        if (n.name () == "output" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< output_type > r (
            output_traits::create (i, f, this));

          this->output_.push_back (r);
          continue;
        }

        // blocks
        //
        if (n.name () == "blocks" && n.namespace_ () == "http://example.com/SimulinkModel")
        {
          ::std::auto_ptr< blocks_type > r (
            blocks_traits::create (i, f, this));

          this->blocks_.push_back (r);
          continue;
        }

        // var
        //
        if (n.name () == "var" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< var_type > r (
            var_traits::create (i, f, this));

          this->var_.push_back (r);
          continue;
        }

        // signal
        //
        if (n.name () == "signal" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< signal_type > r (
            signal_traits::create (i, f, this));

          this->signal_.push_back (r);
          continue;
        }

        // state
        //
        if (n.name () == "state" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< state_type > r (
            state_traits::create (i, f, this));

          this->state_.push_back (r);
          continue;
        }

        // trigger_state
        //
        if (n.name () == "trigger_state" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< trigger_state_type > r (
            trigger_state_traits::create (i, f, this));

          this->trigger_state_.push_back (r);
          continue;
        }

        // invariant_signal
        //
        if (n.name () == "invariant_signal" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< invariant_signal_type > r (
            invariant_signal_traits::create (i, f, this));

          this->invariant_signal_.push_back (r);
          continue;
        }

        // param
        //
        if (n.name () == "param" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< param_type > r (
            param_traits::create (i, f, this));

          this->param_.push_back (r);
          continue;
        }

        // const_param
        //
        if (n.name () == "const_param" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< const_param_type > r (
            const_param_traits::create (i, f, this));

          this->const_param_.push_back (r);
          continue;
        }

        // code
        //
        if (n.name () == "code" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< code_type > r (
            code_traits::create (i, f, this));

          this->code_.push_back (r);
          continue;
        }

        // performance
        //
        if (n.name () == "performance" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< performance_type > r (
            performance_traits::create (i, f, this));

          this->performance_.push_back (r);
          continue;
        }

        // forward
        //
        if (n.name () == "forward" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< forward_type > r (
            forward_traits::create (i, f, this));

          this->forward_.push_back (r);
          continue;
        }

        // backword
        //
        if (n.name () == "backword" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< backword_type > r (
            backword_traits::create (i, f, this));

          this->backword_.push_back (r);
          continue;
        }

        // merged_to
        //
        if (n.name () == "merged_to" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< merged_to_type > r (
            merged_to_traits::create (i, f, this));

          this->merged_to_.push_back (r);
          continue;
        }

        // merge_block
        //
        if (n.name () == "merge_block" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< merge_block_type > r (
            merge_block_traits::create (i, f, this));

          this->merge_block_.push_back (r);
          continue;
        }

        // bind
        //
        if (n.name () == "bind" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< bind_type > r (
            bind_traits::create (i, f, this));

          this->bind_.push_back (r);
          continue;
        }

        // bound_to
        //
        if (n.name () == "bound_to" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< bound_to_type > r (
            bound_to_traits::create (i, f, this));

          this->bound_to_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "blocktype" && n.namespace_ ().empty ())
        {
          this->blocktype_.set (blocktype_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "rate" && n.namespace_ ().empty ())
        {
          this->rate_.set (rate_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "Period" && n.namespace_ ().empty ())
        {
          this->Period_.set (Period_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "PulseType" && n.namespace_ ().empty ())
        {
          this->PulseType_.set (PulseType_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "PulseWidth" && n.namespace_ ().empty ())
        {
          this->PulseWidth_.set (PulseWidth_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "peinfo" && n.namespace_ ().empty ())
        {
          this->peinfo_.set (peinfo_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "priority" && n.namespace_ ().empty ())
        {
          this->priority_.set (priority_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "sequence" && n.namespace_ ().empty ())
        {
          this->sequence_.set (sequence_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "stateflow" && n.namespace_ ().empty ())
        {
          this->stateflow_.set (stateflow_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "DataStoreName" && n.namespace_ ().empty ())
        {
          this->DataStoreName_.set (DataStoreName_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "TreatAsAtomicUnit" && n.namespace_ ().empty ())
        {
          this->TreatAsAtomicUnit_.set (TreatAsAtomicUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "SampleTimeType" && n.namespace_ ().empty ())
        {
          this->SampleTimeType_.set (SampleTimeType_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "TriggerType" && n.namespace_ ().empty ())
        {
          this->TriggerType_.set (TriggerType_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "TriggerSignalSampleTime" && n.namespace_ ().empty ())
        {
          this->TriggerSignalSampleTime_.set (TriggerSignalSampleTime_traits::create (i, f, this));
          continue;
        }
      }

      if (!blocktype_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "blocktype",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    block_T* block_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class block_T (*this, f, c);
    }

    block_T& block_T::
    operator= (const block_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->input_ = x.input_;
        this->output_ = x.output_;
        this->blocks_ = x.blocks_;
        this->var_ = x.var_;
        this->signal_ = x.signal_;
        this->state_ = x.state_;
        this->trigger_state_ = x.trigger_state_;
        this->invariant_signal_ = x.invariant_signal_;
        this->param_ = x.param_;
        this->const_param_ = x.const_param_;
        this->code_ = x.code_;
        this->performance_ = x.performance_;
        this->forward_ = x.forward_;
        this->backword_ = x.backword_;
        this->merged_to_ = x.merged_to_;
        this->merge_block_ = x.merge_block_;
        this->bind_ = x.bind_;
        this->bound_to_ = x.bound_to_;
        this->blocktype_ = x.blocktype_;
        this->name_ = x.name_;
        this->type_ = x.type_;
        this->rate_ = x.rate_;
        this->Period_ = x.Period_;
        this->PulseType_ = x.PulseType_;
        this->PulseWidth_ = x.PulseWidth_;
        this->peinfo_ = x.peinfo_;
        this->id_ = x.id_;
        this->priority_ = x.priority_;
        this->sequence_ = x.sequence_;
        this->stateflow_ = x.stateflow_;
        this->DataStoreName_ = x.DataStoreName_;
        this->TreatAsAtomicUnit_ = x.TreatAsAtomicUnit_;
        this->SampleTimeType_ = x.SampleTimeType_;
        this->TriggerType_ = x.TriggerType_;
        this->TriggerSignalSampleTime_ = x.TriggerSignalSampleTime_;
      }

      return *this;
    }

    block_T::
    ~block_T ()
    {
    }

    // ioport_T
    //

    ioport_T::
    ioport_T (const line_type& line,
              const port_type& port)
    : ::xml_schema::type (),
      connect_ (this),
      line_ (line, this),
      port_ (port, this),
      type_ (this),
      usename_ (this)
    {
    }

    ioport_T::
    ioport_T (const ioport_T& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      connect_ (x.connect_, f, this),
      line_ (x.line_, f, this),
      port_ (x.port_, f, this),
      type_ (x.type_, f, this),
      usename_ (x.usename_, f, this)
    {
    }

    ioport_T::
    ioport_T (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      connect_ (this),
      line_ (this),
      port_ (this),
      type_ (this),
      usename_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ioport_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // connect
        //
        if (n.name () == "connect" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< connect_type > r (
            connect_traits::create (i, f, this));

          this->connect_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "line" && n.namespace_ ().empty ())
        {
          this->line_.set (line_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "port" && n.namespace_ ().empty ())
        {
          this->port_.set (port_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "usename" && n.namespace_ ().empty ())
        {
          this->usename_.set (usename_traits::create (i, f, this));
          continue;
        }
      }

      if (!line_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "line",
          "");
      }

      if (!port_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "port",
          "");
      }
    }

    ioport_T* ioport_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ioport_T (*this, f, c);
    }

    ioport_T& ioport_T::
    operator= (const ioport_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->connect_ = x.connect_;
        this->line_ = x.line_;
        this->port_ = x.port_;
        this->type_ = x.type_;
        this->usename_ = x.usename_;
      }

      return *this;
    }

    ioport_T::
    ~ioport_T ()
    {
    }

    // connection_T
    //

    connection_T::
    connection_T (const block_type& block,
                  const port_type& port)
    : ::xml_schema::type (),
      block_ (block, this),
      port_ (port, this)
    {
    }

    connection_T::
    connection_T (const connection_T& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      block_ (x.block_, f, this),
      port_ (x.port_, f, this)
    {
    }

    connection_T::
    connection_T (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      block_ (this),
      port_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void connection_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "block" && n.namespace_ ().empty ())
        {
          this->block_.set (block_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "port" && n.namespace_ ().empty ())
        {
          this->port_.set (port_traits::create (i, f, this));
          continue;
        }
      }

      if (!block_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "block",
          "");
      }

      if (!port_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "port",
          "");
      }
    }

    connection_T* connection_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class connection_T (*this, f, c);
    }

    connection_T& connection_T::
    operator= (const connection_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->block_ = x.block_;
        this->port_ = x.port_;
      }

      return *this;
    }

    connection_T::
    ~connection_T ()
    {
    }

    // var_T
    //

    var_T::
    var_T (const name_type& name,
           const type_type& type,
           const mode_type& mode)
    : ::xml_schema::type (),
      storage_ (this),
      name_ (name, this),
      type_ (type, this),
      mode_ (mode, this),
      line_ (this),
      port_ (this),
      size_ (this),
      start_ (this),
      end_ (this)
    {
    }

    var_T::
    var_T (const var_T& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      storage_ (x.storage_, f, this),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      mode_ (x.mode_, f, this),
      line_ (x.line_, f, this),
      port_ (x.port_, f, this),
      size_ (x.size_, f, this),
      start_ (x.start_, f, this),
      end_ (x.end_, f, this)
    {
    }

    var_T::
    var_T (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      storage_ (this),
      name_ (this),
      type_ (this),
      mode_ (this),
      line_ (this),
      port_ (this),
      size_ (this),
      start_ (this),
      end_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void var_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "storage" && n.namespace_ ().empty ())
        {
          this->storage_.set (storage_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "mode" && n.namespace_ ().empty ())
        {
          this->mode_.set (mode_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "line" && n.namespace_ ().empty ())
        {
          this->line_.set (line_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "port" && n.namespace_ ().empty ())
        {
          this->port_.set (port_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "size" && n.namespace_ ().empty ())
        {
          this->size_.set (size_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "start" && n.namespace_ ().empty ())
        {
          this->start_.set (start_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "end" && n.namespace_ ().empty ())
        {
          this->end_.set (end_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }

      if (!mode_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "mode",
          "");
      }
    }

    var_T* var_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class var_T (*this, f, c);
    }

    var_T& var_T::
    operator= (const var_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->storage_ = x.storage_;
        this->name_ = x.name_;
        this->type_ = x.type_;
        this->mode_ = x.mode_;
        this->line_ = x.line_;
        this->port_ = x.port_;
        this->size_ = x.size_;
        this->start_ = x.start_;
        this->end_ = x.end_;
      }

      return *this;
    }

    var_T::
    ~var_T ()
    {
    }

    // param_T
    //

    param_T::
    param_T (const storage_type& storage,
             const name_type& name,
             const type_type& type)
    : ::xml_schema::type (),
      storage_ (storage, this),
      name_ (name, this),
      type_ (type, this),
      size_ (this),
      value_ (this)
    {
    }

    param_T::
    param_T (const param_T& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      storage_ (x.storage_, f, this),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this),
      size_ (x.size_, f, this),
      value_ (x.value_, f, this)
    {
    }

    param_T::
    param_T (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      storage_ (this),
      name_ (this),
      type_ (this),
      size_ (this),
      value_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void param_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "storage" && n.namespace_ ().empty ())
        {
          this->storage_.set (storage_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "size" && n.namespace_ ().empty ())
        {
          this->size_.set (size_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!storage_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "storage",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    param_T* param_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class param_T (*this, f, c);
    }

    param_T& param_T::
    operator= (const param_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->storage_ = x.storage_;
        this->name_ = x.name_;
        this->type_ = x.type_;
        this->size_ = x.size_;
        this->value_ = x.value_;
      }

      return *this;
    }

    param_T::
    ~param_T ()
    {
    }

    // code_T
    //

    code_T::
    code_T (const type_type& type)
    : ::xml_schema::string (),
      type_ (type, this),
      file_ (this),
      line_ (this),
      index_ (this)
    {
    }

    code_T::
    code_T (const char* _xsd_string_base,
            const type_type& type)
    : ::xml_schema::string (_xsd_string_base),
      type_ (type, this),
      file_ (this),
      line_ (this),
      index_ (this)
    {
    }

    code_T::
    code_T (const ::std::string& _xsd_string_base,
            const type_type& type)
    : ::xml_schema::string (_xsd_string_base),
      type_ (type, this),
      file_ (this),
      line_ (this),
      index_ (this)
    {
    }

    code_T::
    code_T (const ::xml_schema::string& _xsd_string_base,
            const type_type& type)
    : ::xml_schema::string (_xsd_string_base),
      type_ (type, this),
      file_ (this),
      line_ (this),
      index_ (this)
    {
    }

    code_T::
    code_T (const code_T& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      type_ (x.type_, f, this),
      file_ (x.file_, f, this),
      line_ (x.line_, f, this),
      index_ (x.index_, f, this)
    {
    }

    code_T::
    code_T (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      type_ (this),
      file_ (this),
      line_ (this),
      index_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void code_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "file" && n.namespace_ ().empty ())
        {
          this->file_.set (file_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "line" && n.namespace_ ().empty ())
        {
          this->line_.set (line_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "index" && n.namespace_ ().empty ())
        {
          this->index_.set (index_traits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    code_T* code_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class code_T (*this, f, c);
    }

    code_T& code_T::
    operator= (const code_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::string& > (*this) = x;
        this->type_ = x.type_;
        this->file_ = x.file_;
        this->line_ = x.line_;
        this->index_ = x.index_;
      }

      return *this;
    }

    code_T::
    ~code_T ()
    {
    }

    // performance_T
    //

    performance_T::
    performance_T (const type_type& type,
                   const best_type& best,
                   const typical_type& typical,
                   const worst_type& worst)
    : ::xml_schema::type (),
      type_ (type, this),
      best_ (best, this),
      typical_ (typical, this),
      worst_ (worst, this)
    {
    }

    performance_T::
    performance_T (const performance_T& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      type_ (x.type_, f, this),
      best_ (x.best_, f, this),
      typical_ (x.typical_, f, this),
      worst_ (x.worst_, f, this)
    {
    }

    performance_T::
    performance_T (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      type_ (this),
      best_ (this),
      typical_ (this),
      worst_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void performance_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "best" && n.namespace_ ().empty ())
        {
          this->best_.set (best_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "typical" && n.namespace_ ().empty ())
        {
          this->typical_.set (typical_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "worst" && n.namespace_ ().empty ())
        {
          this->worst_.set (worst_traits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }

      if (!best_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "best",
          "");
      }

      if (!typical_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "typical",
          "");
      }

      if (!worst_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "worst",
          "");
      }
    }

    performance_T* performance_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class performance_T (*this, f, c);
    }

    performance_T& performance_T::
    operator= (const performance_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->type_ = x.type_;
        this->best_ = x.best_;
        this->typical_ = x.typical_;
        this->worst_ = x.worst_;
      }

      return *this;
    }

    performance_T::
    ~performance_T ()
    {
    }

    // link_T
    //

    link_T::
    link_T (const block_type& block,
            const type_type& type)
    : ::xml_schema::type (),
      var_ (this),
      block_ (block, this),
      type_ (type, this),
      label_ (this)
    {
    }

    link_T::
    link_T (const link_T& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      var_ (x.var_, f, this),
      block_ (x.block_, f, this),
      type_ (x.type_, f, this),
      label_ (x.label_, f, this)
    {
    }

    link_T::
    link_T (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      var_ (this),
      block_ (this),
      type_ (this),
      label_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void link_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // var
        //
        if (n.name () == "var" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< var_type > r (
            var_traits::create (i, f, this));

          this->var_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "block" && n.namespace_ ().empty ())
        {
          this->block_.set (block_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "label" && n.namespace_ ().empty ())
        {
          this->label_.set (label_traits::create (i, f, this));
          continue;
        }
      }

      if (!block_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "block",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    link_T* link_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class link_T (*this, f, c);
    }

    link_T& link_T::
    operator= (const link_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->var_ = x.var_;
        this->block_ = x.block_;
        this->type_ = x.type_;
        this->label_ = x.label_;
      }

      return *this;
    }

    link_T::
    ~link_T ()
    {
    }

    // object_T
    //

    object_T::
    object_T (const type_type& type,
              const name_type& name)
    : ::xml_schema::string (),
      type_ (type, this),
      has_struct_ (this),
      name_ (name, this),
      size_ (this),
      value_ (this),
      kind_ (this)
    {
    }

    object_T::
    object_T (const char* _xsd_string_base,
              const type_type& type,
              const name_type& name)
    : ::xml_schema::string (_xsd_string_base),
      type_ (type, this),
      has_struct_ (this),
      name_ (name, this),
      size_ (this),
      value_ (this),
      kind_ (this)
    {
    }

    object_T::
    object_T (const ::std::string& _xsd_string_base,
              const type_type& type,
              const name_type& name)
    : ::xml_schema::string (_xsd_string_base),
      type_ (type, this),
      has_struct_ (this),
      name_ (name, this),
      size_ (this),
      value_ (this),
      kind_ (this)
    {
    }

    object_T::
    object_T (const ::xml_schema::string& _xsd_string_base,
              const type_type& type,
              const name_type& name)
    : ::xml_schema::string (_xsd_string_base),
      type_ (type, this),
      has_struct_ (this),
      name_ (name, this),
      size_ (this),
      value_ (this),
      kind_ (this)
    {
    }

    object_T::
    object_T (const object_T& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      type_ (x.type_, f, this),
      has_struct_ (x.has_struct_, f, this),
      name_ (x.name_, f, this),
      size_ (x.size_, f, this),
      value_ (x.value_, f, this),
      kind_ (x.kind_, f, this)
    {
    }

    object_T::
    object_T (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      type_ (this),
      has_struct_ (this),
      name_ (this),
      size_ (this),
      value_ (this),
      kind_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void object_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "has_struct" && n.namespace_ ().empty ())
        {
          this->has_struct_.set (has_struct_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "size" && n.namespace_ ().empty ())
        {
          this->size_.set (size_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "kind" && n.namespace_ ().empty ())
        {
          this->kind_.set (kind_traits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    object_T* object_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class object_T (*this, f, c);
    }

    object_T& object_T::
    operator= (const object_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::string& > (*this) = x;
        this->type_ = x.type_;
        this->has_struct_ = x.has_struct_;
        this->name_ = x.name_;
        this->size_ = x.size_;
        this->value_ = x.value_;
        this->kind_ = x.kind_;
      }

      return *this;
    }

    object_T::
    ~object_T ()
    {
    }

    // include_T
    //

    include_T::
    include_T (const index_type& index,
               const file_type& file)
    : ::xml_schema::type (),
      index_ (index, this),
      from_ (this),
      file_ (file, this)
    {
    }

    include_T::
    include_T (const include_T& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      index_ (x.index_, f, this),
      from_ (x.from_, f, this),
      file_ (x.file_, f, this)
    {
    }

    include_T::
    include_T (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      index_ (this),
      from_ (this),
      file_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void include_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "index" && n.namespace_ ().empty ())
        {
          this->index_.set (index_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "from" && n.namespace_ ().empty ())
        {
          this->from_.set (from_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "file" && n.namespace_ ().empty ())
        {
          this->file_.set (file_traits::create (i, f, this));
          continue;
        }
      }

      if (!index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "index",
          "");
      }

      if (!file_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "file",
          "");
      }
    }

    include_T* include_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class include_T (*this, f, c);
    }

    include_T& include_T::
    operator= (const include_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->index_ = x.index_;
        this->from_ = x.from_;
        this->file_ = x.file_;
      }

      return *this;
    }

    include_T::
    ~include_T ()
    {
    }

    // function_T
    //

    function_T::
    function_T (const name_type& name,
                const type_type& type)
    : ::xml_schema::type (),
      code_ (this),
      function_ (this),
      name_ (name, this),
      type_ (type, this)
    {
    }

    function_T::
    function_T (const function_T& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      code_ (x.code_, f, this),
      function_ (x.function_, f, this),
      name_ (x.name_, f, this),
      type_ (x.type_, f, this)
    {
    }

    function_T::
    function_T (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      code_ (this),
      function_ (this),
      name_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void function_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // code
        //
        if (n.name () == "code" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< code_type > r (
            code_traits::create (i, f, this));

          if (!this->code_)
          {
            this->code_.set (r);
            continue;
          }
        }

        // function
        //
        if (n.name () == "function" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< function_type > r (
            function_traits::create (i, f, this));

          this->function_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (name_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (type_traits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    function_T* function_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class function_T (*this, f, c);
    }

    function_T& function_T::
    operator= (const function_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->code_ = x.code_;
        this->function_ = x.function_;
        this->name_ = x.name_;
        this->type_ = x.type_;
      }

      return *this;
    }

    function_T::
    ~function_T ()
    {
    }

    // block_name_T
    //

    block_name_T::
    block_name_T (const block_type& block)
    : ::xml_schema::type (),
      block_ (block, this)
    {
    }

    block_name_T::
    block_name_T (const block_name_T& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      block_ (x.block_, f, this)
    {
    }

    block_name_T::
    block_name_T (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      block_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void block_name_T::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "block" && n.namespace_ ().empty ())
        {
          this->block_.set (block_traits::create (i, f, this));
          continue;
        }
      }

      if (!block_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "block",
          "");
      }
    }

    block_name_T* block_name_T::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class block_name_T (*this, f, c);
    }

    block_name_T& block_name_T::
    operator= (const block_name_T& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->block_ = x.block_;
      }

      return *this;
    }

    block_name_T::
    ~block_name_T ()
    {
    }

    // type
    //

    type::
    type (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_type_convert ();
    }

    type::
    type (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_type_convert ();
    }

    type::
    type (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_type_convert ();
    }

    type* type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class type (*this, f, c);
    }

    type::value type::
    _xsd_type_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type_literals_);
      const value* i (::std::lower_bound (
                        _xsd_type_indexes_,
                        _xsd_type_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_type_indexes_ + 6 || _xsd_type_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const type::
    _xsd_type_literals_[6] =
    {
      "shim",
      "shim-schema",
      "c-source",
      "c-header",
      "c-data",
      "xml"
    };

    const type::value type::
    _xsd_type_indexes_[6] =
    {
      ::SimulinkModel::XSD::type::c_data,
      ::SimulinkModel::XSD::type::c_header,
      ::SimulinkModel::XSD::type::c_source,
      ::SimulinkModel::XSD::type::shim,
      ::SimulinkModel::XSD::type::shim_schema,
      ::SimulinkModel::XSD::type::xml
    };

    // element
    //

    element::
    element (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_element_convert ();
    }

    element::
    element (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_element_convert ();
    }

    element::
    element (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_element_convert ();
    }

    element* element::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class element (*this, f, c);
    }

    element::value element::
    _xsd_element_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_element_literals_);
      const value* i (::std::lower_bound (
                        _xsd_element_indexes_,
                        _xsd_element_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_element_indexes_ + 3 || _xsd_element_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const element::
    _xsd_element_literals_[3] =
    {
      "componentset",
      "mastercomponent",
      "commoninstructionset"
    };

    const element::value element::
    _xsd_element_indexes_[3] =
    {
      ::SimulinkModel::XSD::element::commoninstructionset,
      ::SimulinkModel::XSD::element::componentset,
      ::SimulinkModel::XSD::element::mastercomponent
    };

    // mode
    //

    mode::
    mode (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_mode_convert ();
    }

    mode::
    mode (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_mode_convert ();
    }

    mode::
    mode (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_mode_convert ();
    }

    mode* mode::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class mode (*this, f, c);
    }

    mode::value mode::
    _xsd_mode_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_mode_literals_);
      const value* i (::std::lower_bound (
                        _xsd_mode_indexes_,
                        _xsd_mode_indexes_ + 7,
                        *this,
                        c));

      if (i == _xsd_mode_indexes_ + 7 || _xsd_mode_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const mode::
    _xsd_mode_literals_[7] =
    {
      "extin",
      "extout",
      "input",
      "output",
      "state",
      "trigger_state",
      "invariant_signal"
    };

    const mode::value mode::
    _xsd_mode_indexes_[7] =
    {
      ::SimulinkModel::XSD::mode::extin,
      ::SimulinkModel::XSD::mode::extout,
      ::SimulinkModel::XSD::mode::input,
      ::SimulinkModel::XSD::mode::invariant_signal,
      ::SimulinkModel::XSD::mode::output,
      ::SimulinkModel::XSD::mode::state,
      ::SimulinkModel::XSD::mode::trigger_state
    };

    // type1
    //

    type1::
    type1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_type1_convert ();
    }

    type1::
    type1 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_type1_convert ();
    }

    type1::
    type1 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_type1_convert ();
    }

    type1* type1::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class type1 (*this, f, c);
    }

    type1::value type1::
    _xsd_type1_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type1_literals_);
      const value* i (::std::lower_bound (
                        _xsd_type1_indexes_,
                        _xsd_type1_indexes_ + 15,
                        *this,
                        c));

      if (i == _xsd_type1_indexes_ + 15 || _xsd_type1_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const type1::
    _xsd_type1_literals_[15] =
    {
      "task",
      "update",
      "init",
      "state",
      "invariant_signal",
      "param",
      "const",
      "func",
      "autovars",
      "rt-macro",
      "rt-type",
      "rt-code",
      "rt-init",
      "common",
      "common-init"
    };

    const type1::value type1::
    _xsd_type1_indexes_[15] =
    {
      ::SimulinkModel::XSD::type1::autovars,
      ::SimulinkModel::XSD::type1::common,
      ::SimulinkModel::XSD::type1::common_init,
      ::SimulinkModel::XSD::type1::const_,
      ::SimulinkModel::XSD::type1::func,
      ::SimulinkModel::XSD::type1::init,
      ::SimulinkModel::XSD::type1::invariant_signal,
      ::SimulinkModel::XSD::type1::param,
      ::SimulinkModel::XSD::type1::rt_code,
      ::SimulinkModel::XSD::type1::rt_init,
      ::SimulinkModel::XSD::type1::rt_macro,
      ::SimulinkModel::XSD::type1::rt_type,
      ::SimulinkModel::XSD::type1::state,
      ::SimulinkModel::XSD::type1::task,
      ::SimulinkModel::XSD::type1::update
    };

    // type2
    //

    type2::
    type2 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_type2_convert ();
    }

    type2::
    type2 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_type2_convert ();
    }

    type2::
    type2 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_type2_convert ();
    }

    type2* type2::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class type2 (*this, f, c);
    }

    type2::value type2::
    _xsd_type2_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type2_literals_);
      const value* i (::std::lower_bound (
                        _xsd_type2_indexes_,
                        _xsd_type2_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_type2_indexes_ + 3 || _xsd_type2_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const type2::
    _xsd_type2_literals_[3] =
    {
      "task",
      "update",
      "init"
    };

    const type2::value type2::
    _xsd_type2_indexes_[3] =
    {
      ::SimulinkModel::XSD::type2::init,
      ::SimulinkModel::XSD::type2::task,
      ::SimulinkModel::XSD::type2::update
    };

    // type3
    //

    type3::
    type3 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_type3_convert ();
    }

    type3::
    type3 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_type3_convert ();
    }

    type3::
    type3 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_type3_convert ();
    }

    type3* type3::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class type3 (*this, f, c);
    }

    type3::value type3::
    _xsd_type3_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type3_literals_);
      const value* i (::std::lower_bound (
                        _xsd_type3_indexes_,
                        _xsd_type3_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_type3_indexes_ + 3 || _xsd_type3_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const type3::
    _xsd_type3_literals_[3] =
    {
      "data",
      "event",
      "port"
    };

    const type3::value type3::
    _xsd_type3_indexes_[3] =
    {
      ::SimulinkModel::XSD::type3::data,
      ::SimulinkModel::XSD::type3::event,
      ::SimulinkModel::XSD::type3::port
    };

    // kind
    //

    kind::
    kind (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_kind_convert ();
    }

    kind::
    kind (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_kind_convert ();
    }

    kind::
    kind (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_kind_convert ();
    }

    kind* kind::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class kind (*this, f, c);
    }

    kind::value kind::
    _xsd_kind_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_kind_literals_);
      const value* i (::std::lower_bound (
                        _xsd_kind_indexes_,
                        _xsd_kind_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_kind_indexes_ + 6 || _xsd_kind_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const kind::
    _xsd_kind_literals_[6] =
    {
      "rtm-extern",
      "rtm-pointer",
      "rtm-object",
      "bsignal",
      "bstate",
      "param"
    };

    const kind::value kind::
    _xsd_kind_indexes_[6] =
    {
      ::SimulinkModel::XSD::kind::bsignal,
      ::SimulinkModel::XSD::kind::bstate,
      ::SimulinkModel::XSD::kind::param,
      ::SimulinkModel::XSD::kind::rtm_extern,
      ::SimulinkModel::XSD::kind::rtm_object,
      ::SimulinkModel::XSD::kind::rtm_pointer
    };

    // type4
    //

    type4::
    type4 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_type4_convert ();
    }

    type4::
    type4 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_type4_convert ();
    }

    type4::
    type4 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_type4_convert ();
    }

    type4* type4::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class type4 (*this, f, c);
    }

    type4::value type4::
    _xsd_type4_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type4_literals_);
      const value* i (::std::lower_bound (
                        _xsd_type4_indexes_,
                        _xsd_type4_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_type4_indexes_ + 2 || _xsd_type4_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const type4::
    _xsd_type4_literals_[2] =
    {
      "decl",
      "defn"
    };

    const type4::value type4::
    _xsd_type4_indexes_[2] =
    {
      ::SimulinkModel::XSD::type4::decl,
      ::SimulinkModel::XSD::type4::defn
    };
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace SimulinkModel
{
  namespace XSD
  {
    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T > (
        ::SimulinkModel::XSD::blocks (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T > (
        ::SimulinkModel::XSD::blocks (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T > (
        ::SimulinkModel::XSD::blocks (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::SimulinkModel::XSD::blocks (isrc, f, p);
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::SimulinkModel::XSD::blocks (isrc, h, f, p);
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::SimulinkModel::XSD::blocks (isrc, h, f, p);
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::SimulinkModel::XSD::blocks (isrc, f, p);
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::SimulinkModel::XSD::blocks (isrc, h, f, p);
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::SimulinkModel::XSD::blocks (isrc, h, f, p);
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T > (
        ::SimulinkModel::XSD::blocks (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T > (
        ::SimulinkModel::XSD::blocks (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T > (
        ::SimulinkModel::XSD::blocks (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T > (
          ::SimulinkModel::XSD::blocks (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "blocks" &&
          n.namespace_ () == "http://example.com/SimulinkModel")
      {
        ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T > r (
          ::xsd::cxx::tree::traits< ::SimulinkModel::XSD::blocks_T, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "blocks",
        "http://example.com/SimulinkModel");
    }

    ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T >
    blocks (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "blocks" &&
          n.namespace_ () == "http://example.com/SimulinkModel")
      {
        ::std::auto_ptr< ::SimulinkModel::XSD::blocks_T > r (
          ::xsd::cxx::tree::traits< ::SimulinkModel::XSD::blocks_T, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "blocks",
        "http://example.com/SimulinkModel");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace SimulinkModel
{
  namespace XSD
  {
    void
    blocks (::std::ostream& o,
            const ::SimulinkModel::XSD::blocks_T& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::SimulinkModel::XSD::blocks (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    blocks (::std::ostream& o,
            const ::SimulinkModel::XSD::blocks_T& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::SimulinkModel::XSD::blocks (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    blocks (::std::ostream& o,
            const ::SimulinkModel::XSD::blocks_T& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::SimulinkModel::XSD::blocks (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    blocks (::xercesc::XMLFormatTarget& t,
            const ::SimulinkModel::XSD::blocks_T& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::SimulinkModel::XSD::blocks (s, m, f));

      ::xsd::cxx::tree::error_handler< char > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
      }
    }

    void
    blocks (::xercesc::XMLFormatTarget& t,
            const ::SimulinkModel::XSD::blocks_T& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::SimulinkModel::XSD::blocks (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    blocks (::xercesc::XMLFormatTarget& t,
            const ::SimulinkModel::XSD::blocks_T& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::SimulinkModel::XSD::blocks (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< char > ();
      }
    }

    void
    blocks (::xercesc::DOMDocument& d,
            const ::SimulinkModel::XSD::blocks_T& s,
            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "blocks" &&
          n.namespace_ () == "http://example.com/SimulinkModel")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < char > (
          n.name (),
          n.namespace_ (),
          "blocks",
          "http://example.com/SimulinkModel");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    blocks (const ::SimulinkModel::XSD::blocks_T& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "blocks",
          "http://example.com/SimulinkModel",
          m, f));

      ::SimulinkModel::XSD::blocks (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const blocks_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // file
      //
      for (blocks_T::file_const_iterator
           b (i.file ().begin ()), n (i.file ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "file",
            e));

        s << *b;
      }

      // shim-params
      //
      for (blocks_T::shim_params_const_iterator
           b (i.shim_params ().begin ()), n (i.shim_params ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "shim-params",
            e));

        s << *b;
      }

      // block
      //
      for (blocks_T::block_const_iterator
           b (i.block ().begin ()), n (i.block ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "block",
            e));

        s << *b;
      }

      // code
      //
      for (blocks_T::code_const_iterator
           b (i.code ().begin ()), n (i.code ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "code",
            e));

        s << *b;
      }

      // object
      //
      for (blocks_T::object_const_iterator
           b (i.object ().begin ()), n (i.object ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "object",
            e));

        s << *b;
      }

      // deftype
      //
      for (blocks_T::deftype_const_iterator
           b (i.deftype ().begin ()), n (i.deftype ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "deftype",
            e));

        s << *b;
      }

      // includes
      //
      for (blocks_T::includes_const_iterator
           b (i.includes ().begin ()), n (i.includes ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "includes",
            e));

        s << *b;
      }

      // function
      //
      for (blocks_T::function_const_iterator
           b (i.function ().begin ()), n (i.function ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "function",
            e));

        s << *b;
      }

      // name
      //
      if (i.name ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << *i.name ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const file_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // timestamp
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "timestamp",
            e));

        a << i.timestamp ();
      }

      // size
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "size",
            e));

        a << i.size ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const shim_params_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // element
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "element",
            e));

        a << i.element ();
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const block_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // input
      //
      for (block_T::input_const_iterator
           b (i.input ().begin ()), n (i.input ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "input",
            e));

        s << *b;
      }

      // output
      //
      for (block_T::output_const_iterator
           b (i.output ().begin ()), n (i.output ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "output",
            e));

        s << *b;
      }

      // blocks
      //
      for (block_T::blocks_const_iterator
           b (i.blocks ().begin ()), n (i.blocks ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "blocks",
            "http://example.com/SimulinkModel",
            e));

        s << *b;
      }

      // var
      //
      for (block_T::var_const_iterator
           b (i.var ().begin ()), n (i.var ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "var",
            e));

        s << *b;
      }

      // signal
      //
      for (block_T::signal_const_iterator
           b (i.signal ().begin ()), n (i.signal ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "signal",
            e));

        s << *b;
      }

      // state
      //
      for (block_T::state_const_iterator
           b (i.state ().begin ()), n (i.state ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "state",
            e));

        s << *b;
      }

      // trigger_state
      //
      for (block_T::trigger_state_const_iterator
           b (i.trigger_state ().begin ()), n (i.trigger_state ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "trigger_state",
            e));

        s << *b;
      }

      // invariant_signal
      //
      for (block_T::invariant_signal_const_iterator
           b (i.invariant_signal ().begin ()), n (i.invariant_signal ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "invariant_signal",
            e));

        s << *b;
      }

      // param
      //
      for (block_T::param_const_iterator
           b (i.param ().begin ()), n (i.param ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "param",
            e));

        s << *b;
      }

      // const_param
      //
      for (block_T::const_param_const_iterator
           b (i.const_param ().begin ()), n (i.const_param ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "const_param",
            e));

        s << *b;
      }

      // code
      //
      for (block_T::code_const_iterator
           b (i.code ().begin ()), n (i.code ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "code",
            e));

        s << *b;
      }

      // performance
      //
      for (block_T::performance_const_iterator
           b (i.performance ().begin ()), n (i.performance ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "performance",
            e));

        s << *b;
      }

      // forward
      //
      for (block_T::forward_const_iterator
           b (i.forward ().begin ()), n (i.forward ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "forward",
            e));

        s << *b;
      }

      // backword
      //
      for (block_T::backword_const_iterator
           b (i.backword ().begin ()), n (i.backword ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "backword",
            e));

        s << *b;
      }

      // merged_to
      //
      for (block_T::merged_to_const_iterator
           b (i.merged_to ().begin ()), n (i.merged_to ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "merged_to",
            e));

        s << *b;
      }

      // merge_block
      //
      for (block_T::merge_block_const_iterator
           b (i.merge_block ().begin ()), n (i.merge_block ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "merge_block",
            e));

        s << *b;
      }

      // bind
      //
      for (block_T::bind_const_iterator
           b (i.bind ().begin ()), n (i.bind ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "bind",
            e));

        s << *b;
      }

      // bound_to
      //
      for (block_T::bound_to_const_iterator
           b (i.bound_to ().begin ()), n (i.bound_to ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "bound_to",
            e));

        s << *b;
      }

      // blocktype
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "blocktype",
            e));

        a << i.blocktype ();
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // type
      //
      if (i.type ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << *i.type ();
      }

      // rate
      //
      if (i.rate ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "rate",
            e));

        a << *i.rate ();
      }

      // Period
      //
      if (i.Period ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "Period",
            e));

        a << *i.Period ();
      }

      // PulseType
      //
      if (i.PulseType ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "PulseType",
            e));

        a << *i.PulseType ();
      }

      // PulseWidth
      //
      if (i.PulseWidth ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "PulseWidth",
            e));

        a << *i.PulseWidth ();
      }

      // peinfo
      //
      if (i.peinfo ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "peinfo",
            e));

        a << *i.peinfo ();
      }

      // id
      //
      if (i.id ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << *i.id ();
      }

      // priority
      //
      if (i.priority ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "priority",
            e));

        a << *i.priority ();
      }

      // sequence
      //
      if (i.sequence ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "sequence",
            e));

        a << *i.sequence ();
      }

      // stateflow
      //
      if (i.stateflow ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "stateflow",
            e));

        a << *i.stateflow ();
      }

      // DataStoreName
      //
      if (i.DataStoreName ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "DataStoreName",
            e));

        a << *i.DataStoreName ();
      }

      // TreatAsAtomicUnit
      //
      if (i.TreatAsAtomicUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "TreatAsAtomicUnit",
            e));

        a << *i.TreatAsAtomicUnit ();
      }

      // SampleTimeType
      //
      if (i.SampleTimeType ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "SampleTimeType",
            e));

        a << *i.SampleTimeType ();
      }

      // TriggerType
      //
      if (i.TriggerType ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "TriggerType",
            e));

        a << *i.TriggerType ();
      }

      // TriggerSignalSampleTime
      //
      if (i.TriggerSignalSampleTime ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "TriggerSignalSampleTime",
            e));

        a << *i.TriggerSignalSampleTime ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ioport_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // connect
      //
      for (ioport_T::connect_const_iterator
           b (i.connect ().begin ()), n (i.connect ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "connect",
            e));

        s << *b;
      }

      // line
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "line",
            e));

        a << i.line ();
      }

      // port
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "port",
            e));

        a << i.port ();
      }

      // type
      //
      if (i.type ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << *i.type ();
      }

      // usename
      //
      if (i.usename ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "usename",
            e));

        a << *i.usename ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const connection_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // block
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "block",
            e));

        a << i.block ();
      }

      // port
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "port",
            e));

        a << i.port ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const var_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // storage
      //
      if (i.storage ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "storage",
            e));

        a << *i.storage ();
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }

      // mode
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "mode",
            e));

        a << i.mode ();
      }

      // line
      //
      if (i.line ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "line",
            e));

        a << *i.line ();
      }

      // port
      //
      if (i.port ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "port",
            e));

        a << *i.port ();
      }

      // size
      //
      if (i.size ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "size",
            e));

        a << *i.size ();
      }

      // start
      //
      if (i.start ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "start",
            e));

        a << *i.start ();
      }

      // end
      //
      if (i.end ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "end",
            e));

        a << *i.end ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const param_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // storage
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "storage",
            e));

        a << i.storage ();
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }

      // size
      //
      if (i.size ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "size",
            e));

        a << *i.size ();
      }

      // value
      //
      if (i.value ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "value",
            e));

        a << *i.value ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const code_T& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }

      // file
      //
      if (i.file ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "file",
            e));

        a << *i.file ();
      }

      // line
      //
      if (i.line ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "line",
            e));

        a << *i.line ();
      }

      // index
      //
      if (i.index ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "index",
            e));

        a << *i.index ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const performance_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }

      // best
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "best",
            e));

        a << i.best ();
      }

      // typical
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "typical",
            e));

        a << i.typical ();
      }

      // worst
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "worst",
            e));

        a << i.worst ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const link_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // var
      //
      for (link_T::var_const_iterator
           b (i.var ().begin ()), n (i.var ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "var",
            e));

        s << *b;
      }

      // block
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "block",
            e));

        a << i.block ();
      }

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }

      // label
      //
      if (i.label ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "label",
            e));

        a << *i.label ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const object_T& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }

      // has_struct
      //
      if (i.has_struct ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "has_struct",
            e));

        a << *i.has_struct ();
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // size
      //
      if (i.size ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "size",
            e));

        a << *i.size ();
      }

      // value
      //
      if (i.value ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "value",
            e));

        a << *i.value ();
      }

      // kind
      //
      if (i.kind ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "kind",
            e));

        a << *i.kind ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const include_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // index
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "index",
            e));

        a << i.index ();
      }

      // from
      //
      if (i.from ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "from",
            e));

        a << *i.from ();
      }

      // file
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "file",
            e));

        a << i.file ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const function_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // code
      //
      if (i.code ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "code",
            e));

        s << *i.code ();
      }

      // function
      //
      for (function_T::function_const_iterator
           b (i.function ().begin ()), n (i.function ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "function",
            e));

        s << *b;
      }

      // name
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "name",
            e));

        a << i.name ();
      }

      // type
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "type",
            e));

        a << i.type ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const block_name_T& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // block
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "block",
            e));

        a << i.block ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const type& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const type& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const type& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const element& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const element& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const element& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const mode& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const mode& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const mode& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const type1& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const type1& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const type1& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const type2& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const type2& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const type2& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const type3& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const type3& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const type3& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const kind& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const kind& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const kind& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMElement& e, const type4& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const type4& i)
    {
      a << static_cast< const ::xml_schema::string& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const type4& i)
    {
      l << static_cast< const ::xml_schema::string& > (i);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "qgen-xmi.hxx"

namespace QGenXMI
{
  // id_list
  //

  id_list::
  id_list ()
  : ::xsd::cxx::tree::list< ::xml_schema::int_, char > (this)
  {
  }

  id_list::
  id_list (size_type n, const ::xml_schema::int_& x)
  : ::xsd::cxx::tree::list< ::xml_schema::int_, char > (n, x, this)
  {
  }

  id_list::
  id_list (const id_list& o,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (o, f, this)
  {
  }

  // valuetype
  //

  valuetype::
  valuetype (const char* s)
  : ::xml_schema::string (s)
  {
  }

  valuetype::
  valuetype (const ::std::string& s)
  : ::xml_schema::string (s)
  {
  }

  valuetype::
  valuetype (const valuetype& o,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (o, f, c)
  {
  }

  // model
  // 

  const model::elements_type& model::
  elements () const
  {
    return this->elements_.get ();
  }

  model::elements_type& model::
  elements ()
  {
    return this->elements_.get ();
  }

  void model::
  elements (const elements_type& x)
  {
    this->elements_.set (x);
  }

  void model::
  elements (::std::auto_ptr< elements_type > x)
  {
    this->elements_.set (x);
  }

  const model::orphans_sequence& model::
  orphans () const
  {
    return this->orphans_;
  }

  model::orphans_sequence& model::
  orphans ()
  {
    return this->orphans_;
  }

  void model::
  orphans (const orphans_sequence& s)
  {
    this->orphans_ = s;
  }

  const model::id_type& model::
  id () const
  {
    return this->id_.get ();
  }

  model::id_type& model::
  id ()
  {
    return this->id_.get ();
  }

  void model::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void model::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const model::fixedStep_optional& model::
  fixedStep () const
  {
    return this->fixedStep_;
  }

  model::fixedStep_optional& model::
  fixedStep ()
  {
    return this->fixedStep_;
  }

  void model::
  fixedStep (const fixedStep_type& x)
  {
    this->fixedStep_.set (x);
  }

  void model::
  fixedStep (const fixedStep_optional& x)
  {
    this->fixedStep_ = x;
  }

  const model::lastId_optional& model::
  lastId () const
  {
    return this->lastId_;
  }

  model::lastId_optional& model::
  lastId ()
  {
    return this->lastId_;
  }

  void model::
  lastId (const lastId_type& x)
  {
    this->lastId_.set (x);
  }

  void model::
  lastId (const lastId_optional& x)
  {
    this->lastId_ = x;
  }

  const model::lastSavedBy_optional& model::
  lastSavedBy () const
  {
    return this->lastSavedBy_;
  }

  model::lastSavedBy_optional& model::
  lastSavedBy ()
  {
    return this->lastSavedBy_;
  }

  void model::
  lastSavedBy (const lastSavedBy_type& x)
  {
    this->lastSavedBy_.set (x);
  }

  void model::
  lastSavedBy (const lastSavedBy_optional& x)
  {
    this->lastSavedBy_ = x;
  }

  void model::
  lastSavedBy (::std::auto_ptr< lastSavedBy_type > x)
  {
    this->lastSavedBy_.set (x);
  }

  const model::lastSavedOn_optional& model::
  lastSavedOn () const
  {
    return this->lastSavedOn_;
  }

  model::lastSavedOn_optional& model::
  lastSavedOn ()
  {
    return this->lastSavedOn_;
  }

  void model::
  lastSavedOn (const lastSavedOn_type& x)
  {
    this->lastSavedOn_.set (x);
  }

  void model::
  lastSavedOn (const lastSavedOn_optional& x)
  {
    this->lastSavedOn_ = x;
  }

  void model::
  lastSavedOn (::std::auto_ptr< lastSavedOn_type > x)
  {
    this->lastSavedOn_.set (x);
  }

  const model::modelName_type& model::
  modelName () const
  {
    return this->modelName_.get ();
  }

  model::modelName_type& model::
  modelName ()
  {
    return this->modelName_.get ();
  }

  void model::
  modelName (const modelName_type& x)
  {
    this->modelName_.set (x);
  }

  void model::
  modelName (::std::auto_ptr< modelName_type > x)
  {
    this->modelName_.set (x);
  }

  const model::modelVersion_optional& model::
  modelVersion () const
  {
    return this->modelVersion_;
  }

  model::modelVersion_optional& model::
  modelVersion ()
  {
    return this->modelVersion_;
  }

  void model::
  modelVersion (const modelVersion_type& x)
  {
    this->modelVersion_.set (x);
  }

  void model::
  modelVersion (const modelVersion_optional& x)
  {
    this->modelVersion_ = x;
  }

  void model::
  modelVersion (::std::auto_ptr< modelVersion_type > x)
  {
    this->modelVersion_.set (x);
  }

  const model::noNewId_optional& model::
  noNewId () const
  {
    return this->noNewId_;
  }

  model::noNewId_optional& model::
  noNewId ()
  {
    return this->noNewId_;
  }

  void model::
  noNewId (const noNewId_type& x)
  {
    this->noNewId_.set (x);
  }

  void model::
  noNewId (const noNewId_optional& x)
  {
    this->noNewId_ = x;
  }

  const model::taskingType_optional& model::
  taskingType () const
  {
    return this->taskingType_;
  }

  model::taskingType_optional& model::
  taskingType ()
  {
    return this->taskingType_;
  }

  void model::
  taskingType (const taskingType_type& x)
  {
    this->taskingType_.set (x);
  }

  void model::
  taskingType (const taskingType_optional& x)
  {
    this->taskingType_ = x;
  }

  void model::
  taskingType (::std::auto_ptr< taskingType_type > x)
  {
    this->taskingType_.set (x);
  }


  // elements
  // 

  const elements::blocks_sequence& elements::
  blocks () const
  {
    return this->blocks_;
  }

  elements::blocks_sequence& elements::
  blocks ()
  {
    return this->blocks_;
  }

  void elements::
  blocks (const blocks_sequence& s)
  {
    this->blocks_ = s;
  }

  const elements::customTypes_sequence& elements::
  customTypes () const
  {
    return this->customTypes_;
  }

  elements::customTypes_sequence& elements::
  customTypes ()
  {
    return this->customTypes_;
  }

  void elements::
  customTypes (const customTypes_sequence& s)
  {
    this->customTypes_ = s;
  }

  const elements::inDataPorts_sequence& elements::
  inDataPorts () const
  {
    return this->inDataPorts_;
  }

  elements::inDataPorts_sequence& elements::
  inDataPorts ()
  {
    return this->inDataPorts_;
  }

  void elements::
  inDataPorts (const inDataPorts_sequence& s)
  {
    this->inDataPorts_ = s;
  }

  const elements::outDataPorts_sequence& elements::
  outDataPorts () const
  {
    return this->outDataPorts_;
  }

  elements::outDataPorts_sequence& elements::
  outDataPorts ()
  {
    return this->outDataPorts_;
  }

  void elements::
  outDataPorts (const outDataPorts_sequence& s)
  {
    this->outDataPorts_ = s;
  }

  const elements::signals_sequence& elements::
  signals () const
  {
    return this->signals_;
  }

  elements::signals_sequence& elements::
  signals ()
  {
    return this->signals_;
  }

  void elements::
  signals (const signals_sequence& s)
  {
    this->signals_ = s;
  }

  const elements::variables_sequence& elements::
  variables () const
  {
    return this->variables_;
  }

  elements::variables_sequence& elements::
  variables ()
  {
    return this->variables_;
  }

  void elements::
  variables (const variables_sequence& s)
  {
    this->variables_ = s;
  }

  const elements::type_optional& elements::
  type () const
  {
    return this->type_;
  }

  elements::type_optional& elements::
  type ()
  {
    return this->type_;
  }

  void elements::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void elements::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void elements::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const elements::id_type& elements::
  id () const
  {
    return this->id_.get ();
  }

  elements::id_type& elements::
  id ()
  {
    return this->id_.get ();
  }

  void elements::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void elements::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const elements::assignedPriority_optional& elements::
  assignedPriority () const
  {
    return this->assignedPriority_;
  }

  elements::assignedPriority_optional& elements::
  assignedPriority ()
  {
    return this->assignedPriority_;
  }

  void elements::
  assignedPriority (const assignedPriority_type& x)
  {
    this->assignedPriority_.set (x);
  }

  void elements::
  assignedPriority (const assignedPriority_optional& x)
  {
    this->assignedPriority_ = x;
  }

  const elements::assignedPrioritySource_optional& elements::
  assignedPrioritySource () const
  {
    return this->assignedPrioritySource_;
  }

  elements::assignedPrioritySource_optional& elements::
  assignedPrioritySource ()
  {
    return this->assignedPrioritySource_;
  }

  void elements::
  assignedPrioritySource (const assignedPrioritySource_type& x)
  {
    this->assignedPrioritySource_.set (x);
  }

  void elements::
  assignedPrioritySource (const assignedPrioritySource_optional& x)
  {
    this->assignedPrioritySource_ = x;
  }

  void elements::
  assignedPrioritySource (::std::auto_ptr< assignedPrioritySource_type > x)
  {
    this->assignedPrioritySource_.set (x);
  }

  const elements::executionOrder_optional& elements::
  executionOrder () const
  {
    return this->executionOrder_;
  }

  elements::executionOrder_optional& elements::
  executionOrder ()
  {
    return this->executionOrder_;
  }

  void elements::
  executionOrder (const executionOrder_type& x)
  {
    this->executionOrder_.set (x);
  }

  void elements::
  executionOrder (const executionOrder_optional& x)
  {
    this->executionOrder_ = x;
  }

  const elements::externalID_optional& elements::
  externalID () const
  {
    return this->externalID_;
  }

  elements::externalID_optional& elements::
  externalID ()
  {
    return this->externalID_;
  }

  void elements::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void elements::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void elements::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const elements::fcnName_optional& elements::
  fcnName () const
  {
    return this->fcnName_;
  }

  elements::fcnName_optional& elements::
  fcnName ()
  {
    return this->fcnName_;
  }

  void elements::
  fcnName (const fcnName_type& x)
  {
    this->fcnName_.set (x);
  }

  void elements::
  fcnName (const fcnName_optional& x)
  {
    this->fcnName_ = x;
  }

  void elements::
  fcnName (::std::auto_ptr< fcnName_type > x)
  {
    this->fcnName_.set (x);
  }

  const elements::isFixedName_optional& elements::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  elements::isFixedName_optional& elements::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void elements::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void elements::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  void elements::
  isFixedName (::std::auto_ptr< isFixedName_type > x)
  {
    this->isFixedName_.set (x);
  }

  const elements::isFullyTyped_optional& elements::
  isFullyTyped () const
  {
    return this->isFullyTyped_;
  }

  elements::isFullyTyped_optional& elements::
  isFullyTyped ()
  {
    return this->isFullyTyped_;
  }

  void elements::
  isFullyTyped (const isFullyTyped_type& x)
  {
    this->isFullyTyped_.set (x);
  }

  void elements::
  isFullyTyped (const isFullyTyped_optional& x)
  {
    this->isFullyTyped_ = x;
  }

  const elements::isReferenceModel_optional& elements::
  isReferenceModel () const
  {
    return this->isReferenceModel_;
  }

  elements::isReferenceModel_optional& elements::
  isReferenceModel ()
  {
    return this->isReferenceModel_;
  }

  void elements::
  isReferenceModel (const isReferenceModel_type& x)
  {
    this->isReferenceModel_.set (x);
  }

  void elements::
  isReferenceModel (const isReferenceModel_optional& x)
  {
    this->isReferenceModel_ = x;
  }

  const elements::maskType_optional& elements::
  maskType () const
  {
    return this->maskType_;
  }

  elements::maskType_optional& elements::
  maskType ()
  {
    return this->maskType_;
  }

  void elements::
  maskType (const maskType_type& x)
  {
    this->maskType_.set (x);
  }

  void elements::
  maskType (const maskType_optional& x)
  {
    this->maskType_ = x;
  }

  void elements::
  maskType (::std::auto_ptr< maskType_type > x)
  {
    this->maskType_.set (x);
  }

  const elements::name_type& elements::
  name () const
  {
    return this->name_.get ();
  }

  elements::name_type& elements::
  name ()
  {
    return this->name_.get ();
  }

  void elements::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void elements::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const elements::offset_optional& elements::
  offset () const
  {
    return this->offset_;
  }

  elements::offset_optional& elements::
  offset ()
  {
    return this->offset_;
  }

  void elements::
  offset (const offset_type& x)
  {
    this->offset_.set (x);
  }

  void elements::
  offset (const offset_optional& x)
  {
    this->offset_ = x;
  }

  const elements::originalFullName_optional& elements::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  elements::originalFullName_optional& elements::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void elements::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void elements::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void elements::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const elements::originalName_optional& elements::
  originalName () const
  {
    return this->originalName_;
  }

  elements::originalName_optional& elements::
  originalName ()
  {
    return this->originalName_;
  }

  void elements::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void elements::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void elements::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const elements::referencedFullName_optional& elements::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  elements::referencedFullName_optional& elements::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void elements::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void elements::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void elements::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const elements::samplePeriod_optional& elements::
  samplePeriod () const
  {
    return this->samplePeriod_;
  }

  elements::samplePeriod_optional& elements::
  samplePeriod ()
  {
    return this->samplePeriod_;
  }

  void elements::
  samplePeriod (const samplePeriod_type& x)
  {
    this->samplePeriod_.set (x);
  }

  void elements::
  samplePeriod (const samplePeriod_optional& x)
  {
    this->samplePeriod_ = x;
  }

  const elements::sourceBlockName_optional& elements::
  sourceBlockName () const
  {
    return this->sourceBlockName_;
  }

  elements::sourceBlockName_optional& elements::
  sourceBlockName ()
  {
    return this->sourceBlockName_;
  }

  void elements::
  sourceBlockName (const sourceBlockName_type& x)
  {
    this->sourceBlockName_.set (x);
  }

  void elements::
  sourceBlockName (const sourceBlockName_optional& x)
  {
    this->sourceBlockName_ = x;
  }

  void elements::
  sourceBlockName (::std::auto_ptr< sourceBlockName_type > x)
  {
    this->sourceBlockName_.set (x);
  }

  const elements::sourceElementId_optional& elements::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  elements::sourceElementId_optional& elements::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void elements::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void elements::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }

  const elements::style_optional& elements::
  style () const
  {
    return this->style_;
  }

  elements::style_optional& elements::
  style ()
  {
    return this->style_;
  }

  void elements::
  style (const style_type& x)
  {
    this->style_.set (x);
  }

  void elements::
  style (const style_optional& x)
  {
    this->style_ = x;
  }

  void elements::
  style (::std::auto_ptr< style_type > x)
  {
    this->style_.set (x);
  }

  const elements::type1_type& elements::
  type1 () const
  {
    return this->type1_.get ();
  }

  elements::type1_type& elements::
  type1 ()
  {
    return this->type1_.get ();
  }

  void elements::
  type1 (const type1_type& x)
  {
    this->type1_.set (x);
  }

  void elements::
  type1 (::std::auto_ptr< type1_type > x)
  {
    this->type1_.set (x);
  }

  const elements::userDefinedPriority_optional& elements::
  userDefinedPriority () const
  {
    return this->userDefinedPriority_;
  }

  elements::userDefinedPriority_optional& elements::
  userDefinedPriority ()
  {
    return this->userDefinedPriority_;
  }

  void elements::
  userDefinedPriority (const userDefinedPriority_type& x)
  {
    this->userDefinedPriority_.set (x);
  }

  void elements::
  userDefinedPriority (const userDefinedPriority_optional& x)
  {
    this->userDefinedPriority_ = x;
  }


  // blocks
  // 

  const blocks::blocks1_sequence& blocks::
  blocks1 () const
  {
    return this->blocks1_;
  }

  blocks::blocks1_sequence& blocks::
  blocks1 ()
  {
    return this->blocks1_;
  }

  void blocks::
  blocks1 (const blocks1_sequence& s)
  {
    this->blocks1_ = s;
  }

  const blocks::inDataPorts_sequence& blocks::
  inDataPorts () const
  {
    return this->inDataPorts_;
  }

  blocks::inDataPorts_sequence& blocks::
  inDataPorts ()
  {
    return this->inDataPorts_;
  }

  void blocks::
  inDataPorts (const inDataPorts_sequence& s)
  {
    this->inDataPorts_ = s;
  }

  const blocks::inEdgeEnablePort_optional& blocks::
  inEdgeEnablePort () const
  {
    return this->inEdgeEnablePort_;
  }

  blocks::inEdgeEnablePort_optional& blocks::
  inEdgeEnablePort ()
  {
    return this->inEdgeEnablePort_;
  }

  void blocks::
  inEdgeEnablePort (const inEdgeEnablePort_type& x)
  {
    this->inEdgeEnablePort_.set (x);
  }

  void blocks::
  inEdgeEnablePort (const inEdgeEnablePort_optional& x)
  {
    this->inEdgeEnablePort_ = x;
  }

  void blocks::
  inEdgeEnablePort (::std::auto_ptr< inEdgeEnablePort_type > x)
  {
    this->inEdgeEnablePort_.set (x);
  }

  const blocks::inEnablePort_optional& blocks::
  inEnablePort () const
  {
    return this->inEnablePort_;
  }

  blocks::inEnablePort_optional& blocks::
  inEnablePort ()
  {
    return this->inEnablePort_;
  }

  void blocks::
  inEnablePort (const inEnablePort_type& x)
  {
    this->inEnablePort_.set (x);
  }

  void blocks::
  inEnablePort (const inEnablePort_optional& x)
  {
    this->inEnablePort_ = x;
  }

  void blocks::
  inEnablePort (::std::auto_ptr< inEnablePort_type > x)
  {
    this->inEnablePort_.set (x);
  }

  const blocks::outDataPorts_sequence& blocks::
  outDataPorts () const
  {
    return this->outDataPorts_;
  }

  blocks::outDataPorts_sequence& blocks::
  outDataPorts ()
  {
    return this->outDataPorts_;
  }

  void blocks::
  outDataPorts (const outDataPorts_sequence& s)
  {
    this->outDataPorts_ = s;
  }

  const blocks::parameters_sequence& blocks::
  parameters () const
  {
    return this->parameters_;
  }

  blocks::parameters_sequence& blocks::
  parameters ()
  {
    return this->parameters_;
  }

  void blocks::
  parameters (const parameters_sequence& s)
  {
    this->parameters_ = s;
  }

  const blocks::signals_sequence& blocks::
  signals () const
  {
    return this->signals_;
  }

  blocks::signals_sequence& blocks::
  signals ()
  {
    return this->signals_;
  }

  void blocks::
  signals (const signals_sequence& s)
  {
    this->signals_ = s;
  }

  const blocks::inControlPort_optional& blocks::
  inControlPort () const
  {
    return this->inControlPort_;
  }

  blocks::inControlPort_optional& blocks::
  inControlPort ()
  {
    return this->inControlPort_;
  }

  void blocks::
  inControlPort (const inControlPort_type& x)
  {
    this->inControlPort_.set (x);
  }

  void blocks::
  inControlPort (const inControlPort_optional& x)
  {
    this->inControlPort_ = x;
  }

  void blocks::
  inControlPort (::std::auto_ptr< inControlPort_type > x)
  {
    this->inControlPort_.set (x);
  }

  const blocks::outControlPorts_sequence& blocks::
  outControlPorts () const
  {
    return this->outControlPorts_;
  }

  blocks::outControlPorts_sequence& blocks::
  outControlPorts ()
  {
    return this->outControlPorts_;
  }

  void blocks::
  outControlPorts (const outControlPorts_sequence& s)
  {
    this->outControlPorts_ = s;
  }

  const blocks::composition_sequence& blocks::
  composition () const
  {
    return this->composition_;
  }

  blocks::composition_sequence& blocks::
  composition ()
  {
    return this->composition_;
  }

  void blocks::
  composition (const composition_sequence& s)
  {
    this->composition_ = s;
  }

  const blocks::type_optional& blocks::
  type () const
  {
    return this->type_;
  }

  blocks::type_optional& blocks::
  type ()
  {
    return this->type_;
  }

  void blocks::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void blocks::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void blocks::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const blocks::id_type& blocks::
  id () const
  {
    return this->id_.get ();
  }

  blocks::id_type& blocks::
  id ()
  {
    return this->id_.get ();
  }

  void blocks::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void blocks::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const blocks::assignedPriority_optional& blocks::
  assignedPriority () const
  {
    return this->assignedPriority_;
  }

  blocks::assignedPriority_optional& blocks::
  assignedPriority ()
  {
    return this->assignedPriority_;
  }

  void blocks::
  assignedPriority (const assignedPriority_type& x)
  {
    this->assignedPriority_.set (x);
  }

  void blocks::
  assignedPriority (const assignedPriority_optional& x)
  {
    this->assignedPriority_ = x;
  }

  const blocks::assignedPrioritySource_optional& blocks::
  assignedPrioritySource () const
  {
    return this->assignedPrioritySource_;
  }

  blocks::assignedPrioritySource_optional& blocks::
  assignedPrioritySource ()
  {
    return this->assignedPrioritySource_;
  }

  void blocks::
  assignedPrioritySource (const assignedPrioritySource_type& x)
  {
    this->assignedPrioritySource_.set (x);
  }

  void blocks::
  assignedPrioritySource (const assignedPrioritySource_optional& x)
  {
    this->assignedPrioritySource_ = x;
  }

  void blocks::
  assignedPrioritySource (::std::auto_ptr< assignedPrioritySource_type > x)
  {
    this->assignedPrioritySource_.set (x);
  }

  const blocks::executionOrder_optional& blocks::
  executionOrder () const
  {
    return this->executionOrder_;
  }

  blocks::executionOrder_optional& blocks::
  executionOrder ()
  {
    return this->executionOrder_;
  }

  void blocks::
  executionOrder (const executionOrder_type& x)
  {
    this->executionOrder_.set (x);
  }

  void blocks::
  executionOrder (const executionOrder_optional& x)
  {
    this->executionOrder_ = x;
  }

  const blocks::externalID_optional& blocks::
  externalID () const
  {
    return this->externalID_;
  }

  blocks::externalID_optional& blocks::
  externalID ()
  {
    return this->externalID_;
  }

  void blocks::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void blocks::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void blocks::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const blocks::isFixedName_optional& blocks::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  blocks::isFixedName_optional& blocks::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void blocks::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void blocks::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const blocks::isFullyTyped_optional& blocks::
  isFullyTyped () const
  {
    return this->isFullyTyped_;
  }

  blocks::isFullyTyped_optional& blocks::
  isFullyTyped ()
  {
    return this->isFullyTyped_;
  }

  void blocks::
  isFullyTyped (const isFullyTyped_type& x)
  {
    this->isFullyTyped_.set (x);
  }

  void blocks::
  isFullyTyped (const isFullyTyped_optional& x)
  {
    this->isFullyTyped_ = x;
  }

  const blocks::maskType_optional& blocks::
  maskType () const
  {
    return this->maskType_;
  }

  blocks::maskType_optional& blocks::
  maskType ()
  {
    return this->maskType_;
  }

  void blocks::
  maskType (const maskType_type& x)
  {
    this->maskType_.set (x);
  }

  void blocks::
  maskType (const maskType_optional& x)
  {
    this->maskType_ = x;
  }

  void blocks::
  maskType (::std::auto_ptr< maskType_type > x)
  {
    this->maskType_.set (x);
  }

  const blocks::name_type& blocks::
  name () const
  {
    return this->name_.get ();
  }

  blocks::name_type& blocks::
  name ()
  {
    return this->name_.get ();
  }

  void blocks::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void blocks::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const blocks::offset_optional& blocks::
  offset () const
  {
    return this->offset_;
  }

  blocks::offset_optional& blocks::
  offset ()
  {
    return this->offset_;
  }

  void blocks::
  offset (const offset_type& x)
  {
    this->offset_.set (x);
  }

  void blocks::
  offset (const offset_optional& x)
  {
    this->offset_ = x;
  }

  const blocks::originalFullName_optional& blocks::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  blocks::originalFullName_optional& blocks::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void blocks::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void blocks::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void blocks::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const blocks::originalName_optional& blocks::
  originalName () const
  {
    return this->originalName_;
  }

  blocks::originalName_optional& blocks::
  originalName ()
  {
    return this->originalName_;
  }

  void blocks::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void blocks::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void blocks::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const blocks::referencedFullName_optional& blocks::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  blocks::referencedFullName_optional& blocks::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void blocks::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void blocks::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void blocks::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const blocks::samplePeriod_optional& blocks::
  samplePeriod () const
  {
    return this->samplePeriod_;
  }

  blocks::samplePeriod_optional& blocks::
  samplePeriod ()
  {
    return this->samplePeriod_;
  }

  void blocks::
  samplePeriod (const samplePeriod_type& x)
  {
    this->samplePeriod_.set (x);
  }

  void blocks::
  samplePeriod (const samplePeriod_optional& x)
  {
    this->samplePeriod_ = x;
  }

  const blocks::sourceBlockName_optional& blocks::
  sourceBlockName () const
  {
    return this->sourceBlockName_;
  }

  blocks::sourceBlockName_optional& blocks::
  sourceBlockName ()
  {
    return this->sourceBlockName_;
  }

  void blocks::
  sourceBlockName (const sourceBlockName_type& x)
  {
    this->sourceBlockName_.set (x);
  }

  void blocks::
  sourceBlockName (const sourceBlockName_optional& x)
  {
    this->sourceBlockName_ = x;
  }

  void blocks::
  sourceBlockName (::std::auto_ptr< sourceBlockName_type > x)
  {
    this->sourceBlockName_.set (x);
  }

  const blocks::sourceElementId_optional& blocks::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  blocks::sourceElementId_optional& blocks::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void blocks::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void blocks::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }

  const blocks::type1_type& blocks::
  type1 () const
  {
    return this->type1_.get ();
  }

  blocks::type1_type& blocks::
  type1 ()
  {
    return this->type1_.get ();
  }

  void blocks::
  type1 (const type1_type& x)
  {
    this->type1_.set (x);
  }

  void blocks::
  type1 (::std::auto_ptr< type1_type > x)
  {
    this->type1_.set (x);
  }

  const blocks::userDefinedPriority_optional& blocks::
  userDefinedPriority () const
  {
    return this->userDefinedPriority_;
  }

  blocks::userDefinedPriority_optional& blocks::
  userDefinedPriority ()
  {
    return this->userDefinedPriority_;
  }

  void blocks::
  userDefinedPriority (const userDefinedPriority_type& x)
  {
    this->userDefinedPriority_.set (x);
  }

  void blocks::
  userDefinedPriority (const userDefinedPriority_optional& x)
  {
    this->userDefinedPriority_ = x;
  }


  // inDataPorts
  // 

  const inDataPorts::dataType_sequence& inDataPorts::
  dataType () const
  {
    return this->dataType_;
  }

  inDataPorts::dataType_sequence& inDataPorts::
  dataType ()
  {
    return this->dataType_;
  }

  void inDataPorts::
  dataType (const dataType_sequence& s)
  {
    this->dataType_ = s;
  }

  const inDataPorts::type_optional& inDataPorts::
  type () const
  {
    return this->type_;
  }

  inDataPorts::type_optional& inDataPorts::
  type ()
  {
    return this->type_;
  }

  void inDataPorts::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void inDataPorts::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void inDataPorts::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const inDataPorts::id_type& inDataPorts::
  id () const
  {
    return this->id_.get ();
  }

  inDataPorts::id_type& inDataPorts::
  id ()
  {
    return this->id_.get ();
  }

  void inDataPorts::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void inDataPorts::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const inDataPorts::externalID_optional& inDataPorts::
  externalID () const
  {
    return this->externalID_;
  }

  inDataPorts::externalID_optional& inDataPorts::
  externalID ()
  {
    return this->externalID_;
  }

  void inDataPorts::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void inDataPorts::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void inDataPorts::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const inDataPorts::incomingSignal_optional& inDataPorts::
  incomingSignal () const
  {
    return this->incomingSignal_;
  }

  inDataPorts::incomingSignal_optional& inDataPorts::
  incomingSignal ()
  {
    return this->incomingSignal_;
  }

  void inDataPorts::
  incomingSignal (const incomingSignal_type& x)
  {
    this->incomingSignal_.set (x);
  }

  void inDataPorts::
  incomingSignal (const incomingSignal_optional& x)
  {
    this->incomingSignal_ = x;
  }

  void inDataPorts::
  incomingSignal (::std::auto_ptr< incomingSignal_type > x)
  {
    this->incomingSignal_.set (x);
  }

  const inDataPorts::isFixedName_optional& inDataPorts::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  inDataPorts::isFixedName_optional& inDataPorts::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void inDataPorts::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void inDataPorts::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const inDataPorts::isRequiredBySuccessors_optional& inDataPorts::
  isRequiredBySuccessors () const
  {
    return this->isRequiredBySuccessors_;
  }

  inDataPorts::isRequiredBySuccessors_optional& inDataPorts::
  isRequiredBySuccessors ()
  {
    return this->isRequiredBySuccessors_;
  }

  void inDataPorts::
  isRequiredBySuccessors (const isRequiredBySuccessors_type& x)
  {
    this->isRequiredBySuccessors_.set (x);
  }

  void inDataPorts::
  isRequiredBySuccessors (const isRequiredBySuccessors_optional& x)
  {
    this->isRequiredBySuccessors_ = x;
  }

  const inDataPorts::isVirtual_optional& inDataPorts::
  isVirtual () const
  {
    return this->isVirtual_;
  }

  inDataPorts::isVirtual_optional& inDataPorts::
  isVirtual ()
  {
    return this->isVirtual_;
  }

  void inDataPorts::
  isVirtual (const isVirtual_type& x)
  {
    this->isVirtual_.set (x);
  }

  void inDataPorts::
  isVirtual (const isVirtual_optional& x)
  {
    this->isVirtual_ = x;
  }

  const inDataPorts::name_type& inDataPorts::
  name () const
  {
    return this->name_.get ();
  }

  inDataPorts::name_type& inDataPorts::
  name ()
  {
    return this->name_.get ();
  }

  void inDataPorts::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void inDataPorts::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const inDataPorts::originalFullName_optional& inDataPorts::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  inDataPorts::originalFullName_optional& inDataPorts::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void inDataPorts::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void inDataPorts::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void inDataPorts::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const inDataPorts::originalName_optional& inDataPorts::
  originalName () const
  {
    return this->originalName_;
  }

  inDataPorts::originalName_optional& inDataPorts::
  originalName ()
  {
    return this->originalName_;
  }

  void inDataPorts::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void inDataPorts::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void inDataPorts::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const inDataPorts::periodicSampleTime_optional& inDataPorts::
  periodicSampleTime () const
  {
    return this->periodicSampleTime_;
  }

  inDataPorts::periodicSampleTime_optional& inDataPorts::
  periodicSampleTime ()
  {
    return this->periodicSampleTime_;
  }

  void inDataPorts::
  periodicSampleTime (const periodicSampleTime_type& x)
  {
    this->periodicSampleTime_.set (x);
  }

  void inDataPorts::
  periodicSampleTime (const periodicSampleTime_optional& x)
  {
    this->periodicSampleTime_ = x;
  }

  const inDataPorts::portNumber_type& inDataPorts::
  portNumber () const
  {
    return this->portNumber_.get ();
  }

  inDataPorts::portNumber_type& inDataPorts::
  portNumber ()
  {
    return this->portNumber_.get ();
  }

  void inDataPorts::
  portNumber (const portNumber_type& x)
  {
    this->portNumber_.set (x);
  }

  const inDataPorts::referencedFullName_optional& inDataPorts::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  inDataPorts::referencedFullName_optional& inDataPorts::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void inDataPorts::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void inDataPorts::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void inDataPorts::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const inDataPorts::sampleTime_optional& inDataPorts::
  sampleTime () const
  {
    return this->sampleTime_;
  }

  inDataPorts::sampleTime_optional& inDataPorts::
  sampleTime ()
  {
    return this->sampleTime_;
  }

  void inDataPorts::
  sampleTime (const sampleTime_type& x)
  {
    this->sampleTime_.set (x);
  }

  void inDataPorts::
  sampleTime (const sampleTime_optional& x)
  {
    this->sampleTime_ = x;
  }

  const inDataPorts::sourceBlock_optional& inDataPorts::
  sourceBlock () const
  {
    return this->sourceBlock_;
  }

  inDataPorts::sourceBlock_optional& inDataPorts::
  sourceBlock ()
  {
    return this->sourceBlock_;
  }

  void inDataPorts::
  sourceBlock (const sourceBlock_type& x)
  {
    this->sourceBlock_.set (x);
  }

  void inDataPorts::
  sourceBlock (const sourceBlock_optional& x)
  {
    this->sourceBlock_ = x;
  }

  const inDataPorts::sourceElementId_optional& inDataPorts::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  inDataPorts::sourceElementId_optional& inDataPorts::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void inDataPorts::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void inDataPorts::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }

  const inDataPorts::statesWhenEnabling_optional& inDataPorts::
  statesWhenEnabling () const
  {
    return this->statesWhenEnabling_;
  }

  inDataPorts::statesWhenEnabling_optional& inDataPorts::
  statesWhenEnabling ()
  {
    return this->statesWhenEnabling_;
  }

  void inDataPorts::
  statesWhenEnabling (const statesWhenEnabling_type& x)
  {
    this->statesWhenEnabling_.set (x);
  }

  void inDataPorts::
  statesWhenEnabling (const statesWhenEnabling_optional& x)
  {
    this->statesWhenEnabling_ = x;
  }

  void inDataPorts::
  statesWhenEnabling (::std::auto_ptr< statesWhenEnabling_type > x)
  {
    this->statesWhenEnabling_.set (x);
  }


  // outDataPorts
  // 

  const outDataPorts::dataType_sequence& outDataPorts::
  dataType () const
  {
    return this->dataType_;
  }

  outDataPorts::dataType_sequence& outDataPorts::
  dataType ()
  {
    return this->dataType_;
  }

  void outDataPorts::
  dataType (const dataType_sequence& s)
  {
    this->dataType_ = s;
  }

  const outDataPorts::type_optional& outDataPorts::
  type () const
  {
    return this->type_;
  }

  outDataPorts::type_optional& outDataPorts::
  type ()
  {
    return this->type_;
  }

  void outDataPorts::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void outDataPorts::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void outDataPorts::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const outDataPorts::id_type& outDataPorts::
  id () const
  {
    return this->id_.get ();
  }

  outDataPorts::id_type& outDataPorts::
  id ()
  {
    return this->id_.get ();
  }

  void outDataPorts::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void outDataPorts::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const outDataPorts::externalID_optional& outDataPorts::
  externalID () const
  {
    return this->externalID_;
  }

  outDataPorts::externalID_optional& outDataPorts::
  externalID ()
  {
    return this->externalID_;
  }

  void outDataPorts::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void outDataPorts::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void outDataPorts::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const outDataPorts::isFixedName_optional& outDataPorts::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  outDataPorts::isFixedName_optional& outDataPorts::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void outDataPorts::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void outDataPorts::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const outDataPorts::isVirtual_optional& outDataPorts::
  isVirtual () const
  {
    return this->isVirtual_;
  }

  outDataPorts::isVirtual_optional& outDataPorts::
  isVirtual ()
  {
    return this->isVirtual_;
  }

  void outDataPorts::
  isVirtual (const isVirtual_type& x)
  {
    this->isVirtual_.set (x);
  }

  void outDataPorts::
  isVirtual (const isVirtual_optional& x)
  {
    this->isVirtual_ = x;
  }

  const outDataPorts::name_type& outDataPorts::
  name () const
  {
    return this->name_.get ();
  }

  outDataPorts::name_type& outDataPorts::
  name ()
  {
    return this->name_.get ();
  }

  void outDataPorts::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void outDataPorts::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const outDataPorts::originalFullName_optional& outDataPorts::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  outDataPorts::originalFullName_optional& outDataPorts::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void outDataPorts::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void outDataPorts::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void outDataPorts::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const outDataPorts::originalName_optional& outDataPorts::
  originalName () const
  {
    return this->originalName_;
  }

  outDataPorts::originalName_optional& outDataPorts::
  originalName ()
  {
    return this->originalName_;
  }

  void outDataPorts::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void outDataPorts::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void outDataPorts::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const outDataPorts::outgoingSignals_optional& outDataPorts::
  outgoingSignals () const
  {
    return this->outgoingSignals_;
  }

  outDataPorts::outgoingSignals_optional& outDataPorts::
  outgoingSignals ()
  {
    return this->outgoingSignals_;
  }

  void outDataPorts::
  outgoingSignals (const outgoingSignals_type& x)
  {
    this->outgoingSignals_.set (x);
  }

  void outDataPorts::
  outgoingSignals (const outgoingSignals_optional& x)
  {
    this->outgoingSignals_ = x;
  }

  void outDataPorts::
  outgoingSignals (::std::auto_ptr< outgoingSignals_type > x)
  {
    this->outgoingSignals_.set (x);
  }

  const outDataPorts::portNumber_type& outDataPorts::
  portNumber () const
  {
    return this->portNumber_.get ();
  }

  outDataPorts::portNumber_type& outDataPorts::
  portNumber ()
  {
    return this->portNumber_.get ();
  }

  void outDataPorts::
  portNumber (const portNumber_type& x)
  {
    this->portNumber_.set (x);
  }

  const outDataPorts::referencedFullName_optional& outDataPorts::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  outDataPorts::referencedFullName_optional& outDataPorts::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void outDataPorts::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void outDataPorts::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void outDataPorts::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const outDataPorts::resetWhenDisabled_optional& outDataPorts::
  resetWhenDisabled () const
  {
    return this->resetWhenDisabled_;
  }

  outDataPorts::resetWhenDisabled_optional& outDataPorts::
  resetWhenDisabled ()
  {
    return this->resetWhenDisabled_;
  }

  void outDataPorts::
  resetWhenDisabled (const resetWhenDisabled_type& x)
  {
    this->resetWhenDisabled_.set (x);
  }

  void outDataPorts::
  resetWhenDisabled (const resetWhenDisabled_optional& x)
  {
    this->resetWhenDisabled_ = x;
  }

  const outDataPorts::sourceBlock_optional& outDataPorts::
  sourceBlock () const
  {
    return this->sourceBlock_;
  }

  outDataPorts::sourceBlock_optional& outDataPorts::
  sourceBlock ()
  {
    return this->sourceBlock_;
  }

  void outDataPorts::
  sourceBlock (const sourceBlock_type& x)
  {
    this->sourceBlock_.set (x);
  }

  void outDataPorts::
  sourceBlock (const sourceBlock_optional& x)
  {
    this->sourceBlock_ = x;
  }

  const outDataPorts::sourceElementId_optional& outDataPorts::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  outDataPorts::sourceElementId_optional& outDataPorts::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void outDataPorts::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void outDataPorts::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // dataType
  // 

  const dataType::initialValue_sequence& dataType::
  initialValue () const
  {
    return this->initialValue_;
  }

  dataType::initialValue_sequence& dataType::
  initialValue ()
  {
    return this->initialValue_;
  }

  void dataType::
  initialValue (const initialValue_sequence& s)
  {
    this->initialValue_ = s;
  }

  const dataType::type_optional& dataType::
  type () const
  {
    return this->type_;
  }

  dataType::type_optional& dataType::
  type ()
  {
    return this->type_;
  }

  void dataType::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void dataType::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void dataType::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const dataType::id_type& dataType::
  id () const
  {
    return this->id_.get ();
  }

  dataType::id_type& dataType::
  id ()
  {
    return this->id_.get ();
  }

  void dataType::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void dataType::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const dataType::externalID_optional& dataType::
  externalID () const
  {
    return this->externalID_;
  }

  dataType::externalID_optional& dataType::
  externalID ()
  {
    return this->externalID_;
  }

  void dataType::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void dataType::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void dataType::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const dataType::isFixedName_optional& dataType::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  dataType::isFixedName_optional& dataType::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void dataType::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void dataType::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const dataType::name_type& dataType::
  name () const
  {
    return this->name_.get ();
  }

  dataType::name_type& dataType::
  name ()
  {
    return this->name_.get ();
  }

  void dataType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void dataType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const dataType::originalFullName_optional& dataType::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  dataType::originalFullName_optional& dataType::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void dataType::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void dataType::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void dataType::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const dataType::originalName_optional& dataType::
  originalName () const
  {
    return this->originalName_;
  }

  dataType::originalName_optional& dataType::
  originalName ()
  {
    return this->originalName_;
  }

  void dataType::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void dataType::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void dataType::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const dataType::referencedFullName_optional& dataType::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  dataType::referencedFullName_optional& dataType::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void dataType::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void dataType::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void dataType::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const dataType::scope_optional& dataType::
  scope () const
  {
    return this->scope_;
  }

  dataType::scope_optional& dataType::
  scope ()
  {
    return this->scope_;
  }

  void dataType::
  scope (const scope_type& x)
  {
    this->scope_.set (x);
  }

  void dataType::
  scope (const scope_optional& x)
  {
    this->scope_ = x;
  }

  void dataType::
  scope (::std::auto_ptr< scope_type > x)
  {
    this->scope_.set (x);
  }

  const dataType::sourceAction_optional& dataType::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  dataType::sourceAction_optional& dataType::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void dataType::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void dataType::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void dataType::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const dataType::sourceElementId_optional& dataType::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  dataType::sourceElementId_optional& dataType::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void dataType::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void dataType::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // initialValue
  // 

  const initialValue::valueDataType_sequence& initialValue::
  valueDataType () const
  {
    return this->valueDataType_;
  }

  initialValue::valueDataType_sequence& initialValue::
  valueDataType ()
  {
    return this->valueDataType_;
  }

  void initialValue::
  valueDataType (const valueDataType_sequence& s)
  {
    this->valueDataType_ = s;
  }

  const initialValue::type_optional& initialValue::
  type () const
  {
    return this->type_;
  }

  initialValue::type_optional& initialValue::
  type ()
  {
    return this->type_;
  }

  void initialValue::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void initialValue::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void initialValue::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const initialValue::id_type& initialValue::
  id () const
  {
    return this->id_.get ();
  }

  initialValue::id_type& initialValue::
  id ()
  {
    return this->id_.get ();
  }

  void initialValue::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void initialValue::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const initialValue::externalID_optional& initialValue::
  externalID () const
  {
    return this->externalID_;
  }

  initialValue::externalID_optional& initialValue::
  externalID ()
  {
    return this->externalID_;
  }

  void initialValue::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void initialValue::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void initialValue::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const initialValue::isFixedName_optional& initialValue::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  initialValue::isFixedName_optional& initialValue::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void initialValue::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void initialValue::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const initialValue::litValue_type& initialValue::
  litValue () const
  {
    return this->litValue_.get ();
  }

  initialValue::litValue_type& initialValue::
  litValue ()
  {
    return this->litValue_.get ();
  }

  void initialValue::
  litValue (const litValue_type& x)
  {
    this->litValue_.set (x);
  }

  const initialValue::name_type& initialValue::
  name () const
  {
    return this->name_.get ();
  }

  initialValue::name_type& initialValue::
  name ()
  {
    return this->name_.get ();
  }

  void initialValue::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void initialValue::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const initialValue::originalFullName_optional& initialValue::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  initialValue::originalFullName_optional& initialValue::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void initialValue::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void initialValue::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void initialValue::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const initialValue::originalName_optional& initialValue::
  originalName () const
  {
    return this->originalName_;
  }

  initialValue::originalName_optional& initialValue::
  originalName ()
  {
    return this->originalName_;
  }

  void initialValue::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void initialValue::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void initialValue::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const initialValue::referencedFullName_optional& initialValue::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  initialValue::referencedFullName_optional& initialValue::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void initialValue::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void initialValue::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void initialValue::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const initialValue::sourceAction_optional& initialValue::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  initialValue::sourceAction_optional& initialValue::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void initialValue::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void initialValue::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void initialValue::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const initialValue::sourceElementId_optional& initialValue::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  initialValue::sourceElementId_optional& initialValue::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void initialValue::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void initialValue::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // valueDataType
  // 

  const valueDataType::type_optional& valueDataType::
  type () const
  {
    return this->type_;
  }

  valueDataType::type_optional& valueDataType::
  type ()
  {
    return this->type_;
  }

  void valueDataType::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void valueDataType::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void valueDataType::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const valueDataType::id_type& valueDataType::
  id () const
  {
    return this->id_.get ();
  }

  valueDataType::id_type& valueDataType::
  id ()
  {
    return this->id_.get ();
  }

  void valueDataType::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void valueDataType::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const valueDataType::externalID_optional& valueDataType::
  externalID () const
  {
    return this->externalID_;
  }

  valueDataType::externalID_optional& valueDataType::
  externalID ()
  {
    return this->externalID_;
  }

  void valueDataType::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void valueDataType::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void valueDataType::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const valueDataType::isFixedName_optional& valueDataType::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  valueDataType::isFixedName_optional& valueDataType::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void valueDataType::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void valueDataType::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const valueDataType::name_type& valueDataType::
  name () const
  {
    return this->name_.get ();
  }

  valueDataType::name_type& valueDataType::
  name ()
  {
    return this->name_.get ();
  }

  void valueDataType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void valueDataType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const valueDataType::originalFullName_optional& valueDataType::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  valueDataType::originalFullName_optional& valueDataType::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void valueDataType::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void valueDataType::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void valueDataType::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const valueDataType::originalName_optional& valueDataType::
  originalName () const
  {
    return this->originalName_;
  }

  valueDataType::originalName_optional& valueDataType::
  originalName ()
  {
    return this->originalName_;
  }

  void valueDataType::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void valueDataType::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void valueDataType::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const valueDataType::referencedFullName_optional& valueDataType::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  valueDataType::referencedFullName_optional& valueDataType::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void valueDataType::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void valueDataType::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void valueDataType::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const valueDataType::scope_optional& valueDataType::
  scope () const
  {
    return this->scope_;
  }

  valueDataType::scope_optional& valueDataType::
  scope ()
  {
    return this->scope_;
  }

  void valueDataType::
  scope (const scope_type& x)
  {
    this->scope_.set (x);
  }

  void valueDataType::
  scope (const scope_optional& x)
  {
    this->scope_ = x;
  }

  void valueDataType::
  scope (::std::auto_ptr< scope_type > x)
  {
    this->scope_.set (x);
  }

  const valueDataType::sourceAction_optional& valueDataType::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  valueDataType::sourceAction_optional& valueDataType::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void valueDataType::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void valueDataType::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void valueDataType::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const valueDataType::sourceElementId_optional& valueDataType::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  valueDataType::sourceElementId_optional& valueDataType::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void valueDataType::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void valueDataType::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // parameters
  // 

  const parameters::value_sequence& parameters::
  value () const
  {
    return this->value_;
  }

  parameters::value_sequence& parameters::
  value ()
  {
    return this->value_;
  }

  void parameters::
  value (const value_sequence& s)
  {
    this->value_ = s;
  }

  const parameters::type_optional& parameters::
  type () const
  {
    return this->type_;
  }

  parameters::type_optional& parameters::
  type ()
  {
    return this->type_;
  }

  void parameters::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void parameters::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void parameters::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const parameters::id_type& parameters::
  id () const
  {
    return this->id_.get ();
  }

  parameters::id_type& parameters::
  id ()
  {
    return this->id_.get ();
  }

  void parameters::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void parameters::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const parameters::externalID_optional& parameters::
  externalID () const
  {
    return this->externalID_;
  }

  parameters::externalID_optional& parameters::
  externalID ()
  {
    return this->externalID_;
  }

  void parameters::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void parameters::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void parameters::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const parameters::index_optional& parameters::
  index () const
  {
    return this->index_;
  }

  parameters::index_optional& parameters::
  index ()
  {
    return this->index_;
  }

  void parameters::
  index (const index_type& x)
  {
    this->index_.set (x);
  }

  void parameters::
  index (const index_optional& x)
  {
    this->index_ = x;
  }

  const parameters::isFixedName_optional& parameters::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  parameters::isFixedName_optional& parameters::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void parameters::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void parameters::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const parameters::isMask_optional& parameters::
  isMask () const
  {
    return this->isMask_;
  }

  parameters::isMask_optional& parameters::
  isMask ()
  {
    return this->isMask_;
  }

  void parameters::
  isMask (const isMask_type& x)
  {
    this->isMask_.set (x);
  }

  void parameters::
  isMask (const isMask_optional& x)
  {
    this->isMask_ = x;
  }

  const parameters::name_type& parameters::
  name () const
  {
    return this->name_.get ();
  }

  parameters::name_type& parameters::
  name ()
  {
    return this->name_.get ();
  }

  void parameters::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void parameters::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const parameters::originalFullName_optional& parameters::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  parameters::originalFullName_optional& parameters::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void parameters::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void parameters::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void parameters::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const parameters::originalName_optional& parameters::
  originalName () const
  {
    return this->originalName_;
  }

  parameters::originalName_optional& parameters::
  originalName ()
  {
    return this->originalName_;
  }

  void parameters::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void parameters::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void parameters::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const parameters::referencedFullName_optional& parameters::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  parameters::referencedFullName_optional& parameters::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void parameters::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void parameters::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void parameters::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const parameters::scope_optional& parameters::
  scope () const
  {
    return this->scope_;
  }

  parameters::scope_optional& parameters::
  scope ()
  {
    return this->scope_;
  }

  void parameters::
  scope (const scope_type& x)
  {
    this->scope_.set (x);
  }

  void parameters::
  scope (const scope_optional& x)
  {
    this->scope_ = x;
  }

  void parameters::
  scope (::std::auto_ptr< scope_type > x)
  {
    this->scope_.set (x);
  }

  const parameters::sourceAction_optional& parameters::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  parameters::sourceAction_optional& parameters::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void parameters::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void parameters::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void parameters::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const parameters::sourceElementId_optional& parameters::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  parameters::sourceElementId_optional& parameters::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void parameters::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void parameters::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }

  const parameters::storageClass_optional& parameters::
  storageClass () const
  {
    return this->storageClass_;
  }

  parameters::storageClass_optional& parameters::
  storageClass ()
  {
    return this->storageClass_;
  }

  void parameters::
  storageClass (const storageClass_type& x)
  {
    this->storageClass_.set (x);
  }

  void parameters::
  storageClass (const storageClass_optional& x)
  {
    this->storageClass_ = x;
  }

  void parameters::
  storageClass (::std::auto_ptr< storageClass_type > x)
  {
    this->storageClass_.set (x);
  }


  // value
  // 

  const value::argument_sequence& value::
  argument () const
  {
    return this->argument_;
  }

  value::argument_sequence& value::
  argument ()
  {
    return this->argument_;
  }

  void value::
  argument (const argument_sequence& s)
  {
    this->argument_ = s;
  }

  const value::valueDataType_sequence& value::
  valueDataType () const
  {
    return this->valueDataType_;
  }

  value::valueDataType_sequence& value::
  valueDataType ()
  {
    return this->valueDataType_;
  }

  void value::
  valueDataType (const valueDataType_sequence& s)
  {
    this->valueDataType_ = s;
  }

  const value::type_optional& value::
  type () const
  {
    return this->type_;
  }

  value::type_optional& value::
  type ()
  {
    return this->type_;
  }

  void value::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void value::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void value::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const value::id_type& value::
  id () const
  {
    return this->id_.get ();
  }

  value::id_type& value::
  id ()
  {
    return this->id_.get ();
  }

  void value::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void value::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const value::externalID_optional& value::
  externalID () const
  {
    return this->externalID_;
  }

  value::externalID_optional& value::
  externalID ()
  {
    return this->externalID_;
  }

  void value::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void value::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void value::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const value::isFixedName_optional& value::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  value::isFixedName_optional& value::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void value::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void value::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const value::litValue_optional& value::
  litValue () const
  {
    return this->litValue_;
  }

  value::litValue_optional& value::
  litValue ()
  {
    return this->litValue_;
  }

  void value::
  litValue (const litValue_type& x)
  {
    this->litValue_.set (x);
  }

  void value::
  litValue (const litValue_optional& x)
  {
    this->litValue_ = x;
  }

  void value::
  litValue (::std::auto_ptr< litValue_type > x)
  {
    this->litValue_.set (x);
  }

  const value::name_type& value::
  name () const
  {
    return this->name_.get ();
  }

  value::name_type& value::
  name ()
  {
    return this->name_.get ();
  }

  void value::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void value::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const value::operator_optional& value::
  operator_ () const
  {
    return this->operator__;
  }

  value::operator_optional& value::
  operator_ ()
  {
    return this->operator__;
  }

  void value::
  operator_ (const operator_type& x)
  {
    this->operator__.set (x);
  }

  void value::
  operator_ (const operator_optional& x)
  {
    this->operator__ = x;
  }

  void value::
  operator_ (::std::auto_ptr< operator_type > x)
  {
    this->operator__.set (x);
  }

  const value::originalFullName_optional& value::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  value::originalFullName_optional& value::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void value::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void value::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void value::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const value::originalName_optional& value::
  originalName () const
  {
    return this->originalName_;
  }

  value::originalName_optional& value::
  originalName ()
  {
    return this->originalName_;
  }

  void value::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void value::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void value::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const value::referencedFullName_optional& value::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  value::referencedFullName_optional& value::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void value::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void value::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void value::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const value::sourceAction_optional& value::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  value::sourceAction_optional& value::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void value::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void value::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void value::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const value::sourceElement_optional& value::
  sourceElement () const
  {
    return this->sourceElement_;
  }

  value::sourceElement_optional& value::
  sourceElement ()
  {
    return this->sourceElement_;
  }

  void value::
  sourceElement (const sourceElement_type& x)
  {
    this->sourceElement_.set (x);
  }

  void value::
  sourceElement (const sourceElement_optional& x)
  {
    this->sourceElement_ = x;
  }

  const value::sourceElementId_optional& value::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  value::sourceElementId_optional& value::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void value::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void value::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // argument
  // 

  const argument::valueDataType_sequence& argument::
  valueDataType () const
  {
    return this->valueDataType_;
  }

  argument::valueDataType_sequence& argument::
  valueDataType ()
  {
    return this->valueDataType_;
  }

  void argument::
  valueDataType (const valueDataType_sequence& s)
  {
    this->valueDataType_ = s;
  }

  const argument::type_optional& argument::
  type () const
  {
    return this->type_;
  }

  argument::type_optional& argument::
  type ()
  {
    return this->type_;
  }

  void argument::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void argument::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void argument::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const argument::id_type& argument::
  id () const
  {
    return this->id_.get ();
  }

  argument::id_type& argument::
  id ()
  {
    return this->id_.get ();
  }

  void argument::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void argument::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const argument::externalID_optional& argument::
  externalID () const
  {
    return this->externalID_;
  }

  argument::externalID_optional& argument::
  externalID ()
  {
    return this->externalID_;
  }

  void argument::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void argument::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void argument::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const argument::isFixedName_optional& argument::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  argument::isFixedName_optional& argument::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void argument::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void argument::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const argument::litValue_optional& argument::
  litValue () const
  {
    return this->litValue_;
  }

  argument::litValue_optional& argument::
  litValue ()
  {
    return this->litValue_;
  }

  void argument::
  litValue (const litValue_type& x)
  {
    this->litValue_.set (x);
  }

  void argument::
  litValue (const litValue_optional& x)
  {
    this->litValue_ = x;
  }

  const argument::name_type& argument::
  name () const
  {
    return this->name_.get ();
  }

  argument::name_type& argument::
  name ()
  {
    return this->name_.get ();
  }

  void argument::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void argument::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const argument::operator_optional& argument::
  operator_ () const
  {
    return this->operator__;
  }

  argument::operator_optional& argument::
  operator_ ()
  {
    return this->operator__;
  }

  void argument::
  operator_ (const operator_type& x)
  {
    this->operator__.set (x);
  }

  void argument::
  operator_ (const operator_optional& x)
  {
    this->operator__ = x;
  }

  void argument::
  operator_ (::std::auto_ptr< operator_type > x)
  {
    this->operator__.set (x);
  }

  const argument::originalFullName_optional& argument::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  argument::originalFullName_optional& argument::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void argument::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void argument::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void argument::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const argument::originalName_optional& argument::
  originalName () const
  {
    return this->originalName_;
  }

  argument::originalName_optional& argument::
  originalName ()
  {
    return this->originalName_;
  }

  void argument::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void argument::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void argument::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const argument::referencedFullName_optional& argument::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  argument::referencedFullName_optional& argument::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void argument::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void argument::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void argument::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const argument::sourceAction_optional& argument::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  argument::sourceAction_optional& argument::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void argument::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void argument::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void argument::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const argument::sourceElementId_optional& argument::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  argument::sourceElementId_optional& argument::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void argument::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void argument::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // signals
  // 

  const signals::type_optional& signals::
  type () const
  {
    return this->type_;
  }

  signals::type_optional& signals::
  type ()
  {
    return this->type_;
  }

  void signals::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void signals::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void signals::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const signals::id_type& signals::
  id () const
  {
    return this->id_.get ();
  }

  signals::id_type& signals::
  id ()
  {
    return this->id_.get ();
  }

  void signals::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void signals::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const signals::dstPort_optional& signals::
  dstPort () const
  {
    return this->dstPort_;
  }

  signals::dstPort_optional& signals::
  dstPort ()
  {
    return this->dstPort_;
  }

  void signals::
  dstPort (const dstPort_type& x)
  {
    this->dstPort_.set (x);
  }

  void signals::
  dstPort (const dstPort_optional& x)
  {
    this->dstPort_ = x;
  }

  void signals::
  dstPort (::std::auto_ptr< dstPort_type > x)
  {
    this->dstPort_.set (x);
  }

  const signals::externalID_optional& signals::
  externalID () const
  {
    return this->externalID_;
  }

  signals::externalID_optional& signals::
  externalID ()
  {
    return this->externalID_;
  }

  void signals::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void signals::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void signals::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const signals::isFixedName_optional& signals::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  signals::isFixedName_optional& signals::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void signals::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void signals::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const signals::name_type& signals::
  name () const
  {
    return this->name_.get ();
  }

  signals::name_type& signals::
  name ()
  {
    return this->name_.get ();
  }

  void signals::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void signals::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const signals::originalFullName_optional& signals::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  signals::originalFullName_optional& signals::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void signals::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void signals::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void signals::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const signals::originalName_optional& signals::
  originalName () const
  {
    return this->originalName_;
  }

  signals::originalName_optional& signals::
  originalName ()
  {
    return this->originalName_;
  }

  void signals::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void signals::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void signals::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const signals::referencedFullName_optional& signals::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  signals::referencedFullName_optional& signals::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void signals::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void signals::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void signals::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const signals::sampleTime_optional& signals::
  sampleTime () const
  {
    return this->sampleTime_;
  }

  signals::sampleTime_optional& signals::
  sampleTime ()
  {
    return this->sampleTime_;
  }

  void signals::
  sampleTime (const sampleTime_type& x)
  {
    this->sampleTime_.set (x);
  }

  void signals::
  sampleTime (const sampleTime_optional& x)
  {
    this->sampleTime_ = x;
  }

  const signals::sourceElementId_optional& signals::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  signals::sourceElementId_optional& signals::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void signals::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void signals::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }

  const signals::srcPort_optional& signals::
  srcPort () const
  {
    return this->srcPort_;
  }

  signals::srcPort_optional& signals::
  srcPort ()
  {
    return this->srcPort_;
  }

  void signals::
  srcPort (const srcPort_type& x)
  {
    this->srcPort_.set (x);
  }

  void signals::
  srcPort (const srcPort_optional& x)
  {
    this->srcPort_ = x;
  }

  void signals::
  srcPort (::std::auto_ptr< srcPort_type > x)
  {
    this->srcPort_.set (x);
  }

  const signals::storageClass_optional& signals::
  storageClass () const
  {
    return this->storageClass_;
  }

  signals::storageClass_optional& signals::
  storageClass ()
  {
    return this->storageClass_;
  }

  void signals::
  storageClass (const storageClass_type& x)
  {
    this->storageClass_.set (x);
  }

  void signals::
  storageClass (const storageClass_optional& x)
  {
    this->storageClass_ = x;
  }

  void signals::
  storageClass (::std::auto_ptr< storageClass_type > x)
  {
    this->storageClass_.set (x);
  }


  // variables
  // 

  const variables::dataType_sequence& variables::
  dataType () const
  {
    return this->dataType_;
  }

  variables::dataType_sequence& variables::
  dataType ()
  {
    return this->dataType_;
  }

  void variables::
  dataType (const dataType_sequence& s)
  {
    this->dataType_ = s;
  }

  const variables::type_optional& variables::
  type () const
  {
    return this->type_;
  }

  variables::type_optional& variables::
  type ()
  {
    return this->type_;
  }

  void variables::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void variables::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void variables::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const variables::id_type& variables::
  id () const
  {
    return this->id_.get ();
  }

  variables::id_type& variables::
  id ()
  {
    return this->id_.get ();
  }

  void variables::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void variables::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const variables::autoInit_optional& variables::
  autoInit () const
  {
    return this->autoInit_;
  }

  variables::autoInit_optional& variables::
  autoInit ()
  {
    return this->autoInit_;
  }

  void variables::
  autoInit (const autoInit_type& x)
  {
    this->autoInit_.set (x);
  }

  void variables::
  autoInit (const autoInit_optional& x)
  {
    this->autoInit_ = x;
  }

  const variables::externalID_optional& variables::
  externalID () const
  {
    return this->externalID_;
  }

  variables::externalID_optional& variables::
  externalID ()
  {
    return this->externalID_;
  }

  void variables::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void variables::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void variables::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const variables::isConst_optional& variables::
  isConst () const
  {
    return this->isConst_;
  }

  variables::isConst_optional& variables::
  isConst ()
  {
    return this->isConst_;
  }

  void variables::
  isConst (const isConst_type& x)
  {
    this->isConst_.set (x);
  }

  void variables::
  isConst (const isConst_optional& x)
  {
    this->isConst_ = x;
  }

  const variables::isFixedName_optional& variables::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  variables::isFixedName_optional& variables::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void variables::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void variables::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const variables::isIterator_optional& variables::
  isIterator () const
  {
    return this->isIterator_;
  }

  variables::isIterator_optional& variables::
  isIterator ()
  {
    return this->isIterator_;
  }

  void variables::
  isIterator (const isIterator_type& x)
  {
    this->isIterator_.set (x);
  }

  void variables::
  isIterator (const isIterator_optional& x)
  {
    this->isIterator_ = x;
  }

  const variables::isOptimizable_optional& variables::
  isOptimizable () const
  {
    return this->isOptimizable_;
  }

  variables::isOptimizable_optional& variables::
  isOptimizable ()
  {
    return this->isOptimizable_;
  }

  void variables::
  isOptimizable (const isOptimizable_type& x)
  {
    this->isOptimizable_.set (x);
  }

  void variables::
  isOptimizable (const isOptimizable_optional& x)
  {
    this->isOptimizable_ = x;
  }

  const variables::isSignalObject_optional& variables::
  isSignalObject () const
  {
    return this->isSignalObject_;
  }

  variables::isSignalObject_optional& variables::
  isSignalObject ()
  {
    return this->isSignalObject_;
  }

  void variables::
  isSignalObject (const isSignalObject_type& x)
  {
    this->isSignalObject_.set (x);
  }

  void variables::
  isSignalObject (const isSignalObject_optional& x)
  {
    this->isSignalObject_ = x;
  }

  const variables::isStatic_optional& variables::
  isStatic () const
  {
    return this->isStatic_;
  }

  variables::isStatic_optional& variables::
  isStatic ()
  {
    return this->isStatic_;
  }

  void variables::
  isStatic (const isStatic_type& x)
  {
    this->isStatic_.set (x);
  }

  void variables::
  isStatic (const isStatic_optional& x)
  {
    this->isStatic_ = x;
  }

  const variables::isUnreferenced_optional& variables::
  isUnreferenced () const
  {
    return this->isUnreferenced_;
  }

  variables::isUnreferenced_optional& variables::
  isUnreferenced ()
  {
    return this->isUnreferenced_;
  }

  void variables::
  isUnreferenced (const isUnreferenced_type& x)
  {
    this->isUnreferenced_.set (x);
  }

  void variables::
  isUnreferenced (const isUnreferenced_optional& x)
  {
    this->isUnreferenced_ = x;
  }

  const variables::isVolatile_optional& variables::
  isVolatile () const
  {
    return this->isVolatile_;
  }

  variables::isVolatile_optional& variables::
  isVolatile ()
  {
    return this->isVolatile_;
  }

  void variables::
  isVolatile (const isVolatile_type& x)
  {
    this->isVolatile_.set (x);
  }

  void variables::
  isVolatile (const isVolatile_optional& x)
  {
    this->isVolatile_ = x;
  }

  const variables::name_type& variables::
  name () const
  {
    return this->name_.get ();
  }

  variables::name_type& variables::
  name ()
  {
    return this->name_.get ();
  }

  void variables::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void variables::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const variables::originalFullName_optional& variables::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  variables::originalFullName_optional& variables::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void variables::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void variables::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void variables::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const variables::originalName_optional& variables::
  originalName () const
  {
    return this->originalName_;
  }

  variables::originalName_optional& variables::
  originalName ()
  {
    return this->originalName_;
  }

  void variables::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void variables::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void variables::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const variables::referenceBy_optional& variables::
  referenceBy () const
  {
    return this->referenceBy_;
  }

  variables::referenceBy_optional& variables::
  referenceBy ()
  {
    return this->referenceBy_;
  }

  void variables::
  referenceBy (const referenceBy_type& x)
  {
    this->referenceBy_.set (x);
  }

  void variables::
  referenceBy (const referenceBy_optional& x)
  {
    this->referenceBy_ = x;
  }

  void variables::
  referenceBy (::std::auto_ptr< referenceBy_type > x)
  {
    this->referenceBy_.set (x);
  }

  const variables::referencedFullName_optional& variables::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  variables::referencedFullName_optional& variables::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void variables::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void variables::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void variables::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const variables::scope_optional& variables::
  scope () const
  {
    return this->scope_;
  }

  variables::scope_optional& variables::
  scope ()
  {
    return this->scope_;
  }

  void variables::
  scope (const scope_type& x)
  {
    this->scope_.set (x);
  }

  void variables::
  scope (const scope_optional& x)
  {
    this->scope_ = x;
  }

  void variables::
  scope (::std::auto_ptr< scope_type > x)
  {
    this->scope_.set (x);
  }

  const variables::sourceAction_optional& variables::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  variables::sourceAction_optional& variables::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void variables::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void variables::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void variables::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const variables::sourceElementId_optional& variables::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  variables::sourceElementId_optional& variables::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void variables::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void variables::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // orphans
  // 

  const orphans::valueDataType_sequence& orphans::
  valueDataType () const
  {
    return this->valueDataType_;
  }

  orphans::valueDataType_sequence& orphans::
  valueDataType ()
  {
    return this->valueDataType_;
  }

  void orphans::
  valueDataType (const valueDataType_sequence& s)
  {
    this->valueDataType_ = s;
  }

  const orphans::argument_sequence& orphans::
  argument () const
  {
    return this->argument_;
  }

  orphans::argument_sequence& orphans::
  argument ()
  {
    return this->argument_;
  }

  void orphans::
  argument (const argument_sequence& s)
  {
    this->argument_ = s;
  }

  const orphans::type_optional& orphans::
  type () const
  {
    return this->type_;
  }

  orphans::type_optional& orphans::
  type ()
  {
    return this->type_;
  }

  void orphans::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void orphans::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void orphans::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const orphans::id_type& orphans::
  id () const
  {
    return this->id_.get ();
  }

  orphans::id_type& orphans::
  id ()
  {
    return this->id_.get ();
  }

  void orphans::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void orphans::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const orphans::externalID_optional& orphans::
  externalID () const
  {
    return this->externalID_;
  }

  orphans::externalID_optional& orphans::
  externalID ()
  {
    return this->externalID_;
  }

  void orphans::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void orphans::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void orphans::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const orphans::isFixedName_optional& orphans::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  orphans::isFixedName_optional& orphans::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void orphans::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void orphans::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const orphans::litValue_optional& orphans::
  litValue () const
  {
    return this->litValue_;
  }

  orphans::litValue_optional& orphans::
  litValue ()
  {
    return this->litValue_;
  }

  void orphans::
  litValue (const litValue_type& x)
  {
    this->litValue_.set (x);
  }

  void orphans::
  litValue (const litValue_optional& x)
  {
    this->litValue_ = x;
  }

  const orphans::name_type& orphans::
  name () const
  {
    return this->name_.get ();
  }

  orphans::name_type& orphans::
  name ()
  {
    return this->name_.get ();
  }

  void orphans::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void orphans::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const orphans::operator_optional& orphans::
  operator_ () const
  {
    return this->operator__;
  }

  orphans::operator_optional& orphans::
  operator_ ()
  {
    return this->operator__;
  }

  void orphans::
  operator_ (const operator_type& x)
  {
    this->operator__.set (x);
  }

  void orphans::
  operator_ (const operator_optional& x)
  {
    this->operator__ = x;
  }

  void orphans::
  operator_ (::std::auto_ptr< operator_type > x)
  {
    this->operator__.set (x);
  }

  const orphans::originalFullName_optional& orphans::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  orphans::originalFullName_optional& orphans::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void orphans::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void orphans::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void orphans::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const orphans::originalName_optional& orphans::
  originalName () const
  {
    return this->originalName_;
  }

  orphans::originalName_optional& orphans::
  originalName ()
  {
    return this->originalName_;
  }

  void orphans::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void orphans::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void orphans::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const orphans::referencedFullName_optional& orphans::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  orphans::referencedFullName_optional& orphans::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void orphans::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void orphans::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void orphans::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const orphans::sourceAction_optional& orphans::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  orphans::sourceAction_optional& orphans::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void orphans::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void orphans::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void orphans::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const orphans::sourceElementId_optional& orphans::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  orphans::sourceElementId_optional& orphans::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void orphans::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void orphans::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }

  const orphans::variable_optional& orphans::
  variable () const
  {
    return this->variable_;
  }

  orphans::variable_optional& orphans::
  variable ()
  {
    return this->variable_;
  }

  void orphans::
  variable (const variable_type& x)
  {
    this->variable_.set (x);
  }

  void orphans::
  variable (const variable_optional& x)
  {
    this->variable_ = x;
  }


  // sideArgument
  // 

  const sideArgument::expresion_sequence& sideArgument::
  expresion () const
  {
    return this->expresion_;
  }

  sideArgument::expresion_sequence& sideArgument::
  expresion ()
  {
    return this->expresion_;
  }

  void sideArgument::
  expresion (const expresion_sequence& s)
  {
    this->expresion_ = s;
  }

  const sideArgument::valueDataType_sequence& sideArgument::
  valueDataType () const
  {
    return this->valueDataType_;
  }

  sideArgument::valueDataType_sequence& sideArgument::
  valueDataType ()
  {
    return this->valueDataType_;
  }

  void sideArgument::
  valueDataType (const valueDataType_sequence& s)
  {
    this->valueDataType_ = s;
  }

  const sideArgument::arguments_sequence& sideArgument::
  arguments () const
  {
    return this->arguments_;
  }

  sideArgument::arguments_sequence& sideArgument::
  arguments ()
  {
    return this->arguments_;
  }

  void sideArgument::
  arguments (const arguments_sequence& s)
  {
    this->arguments_ = s;
  }

  const sideArgument::type_optional& sideArgument::
  type () const
  {
    return this->type_;
  }

  sideArgument::type_optional& sideArgument::
  type ()
  {
    return this->type_;
  }

  void sideArgument::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void sideArgument::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void sideArgument::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const sideArgument::id_type& sideArgument::
  id () const
  {
    return this->id_.get ();
  }

  sideArgument::id_type& sideArgument::
  id ()
  {
    return this->id_.get ();
  }

  void sideArgument::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void sideArgument::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const sideArgument::externalID_optional& sideArgument::
  externalID () const
  {
    return this->externalID_;
  }

  sideArgument::externalID_optional& sideArgument::
  externalID ()
  {
    return this->externalID_;
  }

  void sideArgument::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void sideArgument::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void sideArgument::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const sideArgument::isFixedName_optional& sideArgument::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  sideArgument::isFixedName_optional& sideArgument::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void sideArgument::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void sideArgument::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const sideArgument::name_type& sideArgument::
  name () const
  {
    return this->name_.get ();
  }

  sideArgument::name_type& sideArgument::
  name ()
  {
    return this->name_.get ();
  }

  void sideArgument::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void sideArgument::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const sideArgument::originalFullName_optional& sideArgument::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  sideArgument::originalFullName_optional& sideArgument::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void sideArgument::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void sideArgument::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void sideArgument::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const sideArgument::originalName_optional& sideArgument::
  originalName () const
  {
    return this->originalName_;
  }

  sideArgument::originalName_optional& sideArgument::
  originalName ()
  {
    return this->originalName_;
  }

  void sideArgument::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void sideArgument::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void sideArgument::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const sideArgument::referencedFullName_optional& sideArgument::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  sideArgument::referencedFullName_optional& sideArgument::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void sideArgument::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void sideArgument::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void sideArgument::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const sideArgument::sourceAction_optional& sideArgument::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  sideArgument::sourceAction_optional& sideArgument::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void sideArgument::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void sideArgument::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void sideArgument::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const sideArgument::sourceElementId_optional& sideArgument::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  sideArgument::sourceElementId_optional& sideArgument::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void sideArgument::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void sideArgument::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }

  const sideArgument::standardFunction_optional& sideArgument::
  standardFunction () const
  {
    return this->standardFunction_;
  }

  sideArgument::standardFunction_optional& sideArgument::
  standardFunction ()
  {
    return this->standardFunction_;
  }

  void sideArgument::
  standardFunction (const standardFunction_type& x)
  {
    this->standardFunction_.set (x);
  }

  void sideArgument::
  standardFunction (const standardFunction_optional& x)
  {
    this->standardFunction_ = x;
  }

  void sideArgument::
  standardFunction (::std::auto_ptr< standardFunction_type > x)
  {
    this->standardFunction_.set (x);
  }


  // expression
  // 

  const expression::leftArgument_sequence& expression::
  leftArgument () const
  {
    return this->leftArgument_;
  }

  expression::leftArgument_sequence& expression::
  leftArgument ()
  {
    return this->leftArgument_;
  }

  void expression::
  leftArgument (const leftArgument_sequence& s)
  {
    this->leftArgument_ = s;
  }

  const expression::rightArgument_sequence& expression::
  rightArgument () const
  {
    return this->rightArgument_;
  }

  expression::rightArgument_sequence& expression::
  rightArgument ()
  {
    return this->rightArgument_;
  }

  void expression::
  rightArgument (const rightArgument_sequence& s)
  {
    this->rightArgument_ = s;
  }

  const expression::type_optional& expression::
  type () const
  {
    return this->type_;
  }

  expression::type_optional& expression::
  type ()
  {
    return this->type_;
  }

  void expression::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void expression::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void expression::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const expression::id_type& expression::
  id () const
  {
    return this->id_.get ();
  }

  expression::id_type& expression::
  id ()
  {
    return this->id_.get ();
  }

  void expression::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void expression::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const expression::externalID_optional& expression::
  externalID () const
  {
    return this->externalID_;
  }

  expression::externalID_optional& expression::
  externalID ()
  {
    return this->externalID_;
  }

  void expression::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void expression::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void expression::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const expression::isFixedName_optional& expression::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  expression::isFixedName_optional& expression::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void expression::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void expression::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const expression::name_type& expression::
  name () const
  {
    return this->name_.get ();
  }

  expression::name_type& expression::
  name ()
  {
    return this->name_.get ();
  }

  void expression::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void expression::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const expression::operator_optional& expression::
  operator_ () const
  {
    return this->operator__;
  }

  expression::operator_optional& expression::
  operator_ ()
  {
    return this->operator__;
  }

  void expression::
  operator_ (const operator_type& x)
  {
    this->operator__.set (x);
  }

  void expression::
  operator_ (const operator_optional& x)
  {
    this->operator__ = x;
  }

  void expression::
  operator_ (::std::auto_ptr< operator_type > x)
  {
    this->operator__.set (x);
  }

  const expression::originalFullName_optional& expression::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  expression::originalFullName_optional& expression::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void expression::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void expression::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void expression::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const expression::originalName_optional& expression::
  originalName () const
  {
    return this->originalName_;
  }

  expression::originalName_optional& expression::
  originalName ()
  {
    return this->originalName_;
  }

  void expression::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void expression::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void expression::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const expression::referencedFullName_optional& expression::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  expression::referencedFullName_optional& expression::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void expression::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void expression::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void expression::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const expression::sourceAction_optional& expression::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  expression::sourceAction_optional& expression::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void expression::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void expression::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void expression::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const expression::sourceElementId_optional& expression::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  expression::sourceElementId_optional& expression::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void expression::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void expression::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // composition
  // 

  const composition::defaultTransitions_sequence& composition::
  defaultTransitions () const
  {
    return this->defaultTransitions_;
  }

  composition::defaultTransitions_sequence& composition::
  defaultTransitions ()
  {
    return this->defaultTransitions_;
  }

  void composition::
  defaultTransitions (const defaultTransitions_sequence& s)
  {
    this->defaultTransitions_ = s;
  }

  const composition::junctions_sequence& composition::
  junctions () const
  {
    return this->junctions_;
  }

  composition::junctions_sequence& composition::
  junctions ()
  {
    return this->junctions_;
  }

  void composition::
  junctions (const junctions_sequence& s)
  {
    this->junctions_ = s;
  }

  const composition::states_sequence& composition::
  states () const
  {
    return this->states_;
  }

  composition::states_sequence& composition::
  states ()
  {
    return this->states_;
  }

  void composition::
  states (const states_sequence& s)
  {
    this->states_ = s;
  }

  const composition::type_optional& composition::
  type () const
  {
    return this->type_;
  }

  composition::type_optional& composition::
  type ()
  {
    return this->type_;
  }

  void composition::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void composition::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void composition::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const composition::id_type& composition::
  id () const
  {
    return this->id_.get ();
  }

  composition::id_type& composition::
  id ()
  {
    return this->id_.get ();
  }

  void composition::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void composition::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const composition::externalID_optional& composition::
  externalID () const
  {
    return this->externalID_;
  }

  composition::externalID_optional& composition::
  externalID ()
  {
    return this->externalID_;
  }

  void composition::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void composition::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void composition::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const composition::isFixedName_optional& composition::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  composition::isFixedName_optional& composition::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void composition::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void composition::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const composition::name_type& composition::
  name () const
  {
    return this->name_.get ();
  }

  composition::name_type& composition::
  name ()
  {
    return this->name_.get ();
  }

  void composition::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void composition::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const composition::originalFullName_optional& composition::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  composition::originalFullName_optional& composition::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void composition::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void composition::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void composition::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const composition::originalName_optional& composition::
  originalName () const
  {
    return this->originalName_;
  }

  composition::originalName_optional& composition::
  originalName ()
  {
    return this->originalName_;
  }

  void composition::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void composition::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void composition::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const composition::referencedFullName_optional& composition::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  composition::referencedFullName_optional& composition::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void composition::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void composition::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void composition::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const composition::sourceElementId_optional& composition::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  composition::sourceElementId_optional& composition::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void composition::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void composition::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // defaultTransitions
  // 

  const defaultTransitions::type_optional& defaultTransitions::
  type () const
  {
    return this->type_;
  }

  defaultTransitions::type_optional& defaultTransitions::
  type ()
  {
    return this->type_;
  }

  void defaultTransitions::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void defaultTransitions::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void defaultTransitions::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const defaultTransitions::id_type& defaultTransitions::
  id () const
  {
    return this->id_.get ();
  }

  defaultTransitions::id_type& defaultTransitions::
  id ()
  {
    return this->id_.get ();
  }

  void defaultTransitions::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void defaultTransitions::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const defaultTransitions::destination_optional& defaultTransitions::
  destination () const
  {
    return this->destination_;
  }

  defaultTransitions::destination_optional& defaultTransitions::
  destination ()
  {
    return this->destination_;
  }

  void defaultTransitions::
  destination (const destination_type& x)
  {
    this->destination_.set (x);
  }

  void defaultTransitions::
  destination (const destination_optional& x)
  {
    this->destination_ = x;
  }

  const defaultTransitions::executionOrder_optional& defaultTransitions::
  executionOrder () const
  {
    return this->executionOrder_;
  }

  defaultTransitions::executionOrder_optional& defaultTransitions::
  executionOrder ()
  {
    return this->executionOrder_;
  }

  void defaultTransitions::
  executionOrder (const executionOrder_type& x)
  {
    this->executionOrder_.set (x);
  }

  void defaultTransitions::
  executionOrder (const executionOrder_optional& x)
  {
    this->executionOrder_ = x;
  }

  const defaultTransitions::externalID_optional& defaultTransitions::
  externalID () const
  {
    return this->externalID_;
  }

  defaultTransitions::externalID_optional& defaultTransitions::
  externalID ()
  {
    return this->externalID_;
  }

  void defaultTransitions::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void defaultTransitions::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void defaultTransitions::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const defaultTransitions::isFixedName_optional& defaultTransitions::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  defaultTransitions::isFixedName_optional& defaultTransitions::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void defaultTransitions::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void defaultTransitions::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const defaultTransitions::name_type& defaultTransitions::
  name () const
  {
    return this->name_.get ();
  }

  defaultTransitions::name_type& defaultTransitions::
  name ()
  {
    return this->name_.get ();
  }

  void defaultTransitions::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void defaultTransitions::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const defaultTransitions::originalFullName_optional& defaultTransitions::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  defaultTransitions::originalFullName_optional& defaultTransitions::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void defaultTransitions::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void defaultTransitions::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void defaultTransitions::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const defaultTransitions::originalName_optional& defaultTransitions::
  originalName () const
  {
    return this->originalName_;
  }

  defaultTransitions::originalName_optional& defaultTransitions::
  originalName ()
  {
    return this->originalName_;
  }

  void defaultTransitions::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void defaultTransitions::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void defaultTransitions::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const defaultTransitions::referencedFullName_optional& defaultTransitions::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  defaultTransitions::referencedFullName_optional& defaultTransitions::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void defaultTransitions::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void defaultTransitions::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void defaultTransitions::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const defaultTransitions::sourceElementId_optional& defaultTransitions::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  defaultTransitions::sourceElementId_optional& defaultTransitions::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void defaultTransitions::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void defaultTransitions::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }

  const defaultTransitions::type1_optional& defaultTransitions::
  type1 () const
  {
    return this->type1_;
  }

  defaultTransitions::type1_optional& defaultTransitions::
  type1 ()
  {
    return this->type1_;
  }

  void defaultTransitions::
  type1 (const type1_type& x)
  {
    this->type1_.set (x);
  }

  void defaultTransitions::
  type1 (const type1_optional& x)
  {
    this->type1_ = x;
  }

  void defaultTransitions::
  type1 (::std::auto_ptr< type1_type > x)
  {
    this->type1_.set (x);
  }


  // junctions
  // 

  const junctions::transitions_sequence& junctions::
  transitions () const
  {
    return this->transitions_;
  }

  junctions::transitions_sequence& junctions::
  transitions ()
  {
    return this->transitions_;
  }

  void junctions::
  transitions (const transitions_sequence& s)
  {
    this->transitions_ = s;
  }

  const junctions::type_optional& junctions::
  type () const
  {
    return this->type_;
  }

  junctions::type_optional& junctions::
  type ()
  {
    return this->type_;
  }

  void junctions::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void junctions::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void junctions::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const junctions::id_type& junctions::
  id () const
  {
    return this->id_.get ();
  }

  junctions::id_type& junctions::
  id ()
  {
    return this->id_.get ();
  }

  void junctions::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void junctions::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const junctions::externalID_optional& junctions::
  externalID () const
  {
    return this->externalID_;
  }

  junctions::externalID_optional& junctions::
  externalID ()
  {
    return this->externalID_;
  }

  void junctions::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void junctions::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void junctions::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const junctions::isFixedName_optional& junctions::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  junctions::isFixedName_optional& junctions::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void junctions::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void junctions::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const junctions::junctionType_optional& junctions::
  junctionType () const
  {
    return this->junctionType_;
  }

  junctions::junctionType_optional& junctions::
  junctionType ()
  {
    return this->junctionType_;
  }

  void junctions::
  junctionType (const junctionType_type& x)
  {
    this->junctionType_.set (x);
  }

  void junctions::
  junctionType (const junctionType_optional& x)
  {
    this->junctionType_ = x;
  }

  void junctions::
  junctionType (::std::auto_ptr< junctionType_type > x)
  {
    this->junctionType_.set (x);
  }

  const junctions::name_type& junctions::
  name () const
  {
    return this->name_.get ();
  }

  junctions::name_type& junctions::
  name ()
  {
    return this->name_.get ();
  }

  void junctions::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void junctions::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const junctions::originalFullName_optional& junctions::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  junctions::originalFullName_optional& junctions::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void junctions::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void junctions::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void junctions::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const junctions::originalName_optional& junctions::
  originalName () const
  {
    return this->originalName_;
  }

  junctions::originalName_optional& junctions::
  originalName ()
  {
    return this->originalName_;
  }

  void junctions::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void junctions::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void junctions::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const junctions::referencedFullName_optional& junctions::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  junctions::referencedFullName_optional& junctions::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void junctions::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void junctions::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void junctions::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const junctions::sourceElementId_optional& junctions::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  junctions::sourceElementId_optional& junctions::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void junctions::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void junctions::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // transitions
  // 

  const transitions::guard_sequence& transitions::
  guard () const
  {
    return this->guard_;
  }

  transitions::guard_sequence& transitions::
  guard ()
  {
    return this->guard_;
  }

  void transitions::
  guard (const guard_sequence& s)
  {
    this->guard_ = s;
  }

  const transitions::type_optional& transitions::
  type () const
  {
    return this->type_;
  }

  transitions::type_optional& transitions::
  type ()
  {
    return this->type_;
  }

  void transitions::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void transitions::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void transitions::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const transitions::id_type& transitions::
  id () const
  {
    return this->id_.get ();
  }

  transitions::id_type& transitions::
  id ()
  {
    return this->id_.get ();
  }

  void transitions::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void transitions::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const transitions::destination_optional& transitions::
  destination () const
  {
    return this->destination_;
  }

  transitions::destination_optional& transitions::
  destination ()
  {
    return this->destination_;
  }

  void transitions::
  destination (const destination_type& x)
  {
    this->destination_.set (x);
  }

  void transitions::
  destination (const destination_optional& x)
  {
    this->destination_ = x;
  }

  const transitions::executionOrder_optional& transitions::
  executionOrder () const
  {
    return this->executionOrder_;
  }

  transitions::executionOrder_optional& transitions::
  executionOrder ()
  {
    return this->executionOrder_;
  }

  void transitions::
  executionOrder (const executionOrder_type& x)
  {
    this->executionOrder_.set (x);
  }

  void transitions::
  executionOrder (const executionOrder_optional& x)
  {
    this->executionOrder_ = x;
  }

  const transitions::externalID_optional& transitions::
  externalID () const
  {
    return this->externalID_;
  }

  transitions::externalID_optional& transitions::
  externalID ()
  {
    return this->externalID_;
  }

  void transitions::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void transitions::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void transitions::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const transitions::isFixedName_optional& transitions::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  transitions::isFixedName_optional& transitions::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void transitions::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void transitions::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const transitions::name_type& transitions::
  name () const
  {
    return this->name_.get ();
  }

  transitions::name_type& transitions::
  name ()
  {
    return this->name_.get ();
  }

  void transitions::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void transitions::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const transitions::originalFullName_optional& transitions::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  transitions::originalFullName_optional& transitions::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void transitions::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void transitions::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void transitions::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const transitions::originalName_optional& transitions::
  originalName () const
  {
    return this->originalName_;
  }

  transitions::originalName_optional& transitions::
  originalName ()
  {
    return this->originalName_;
  }

  void transitions::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void transitions::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void transitions::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const transitions::referencedFullName_optional& transitions::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  transitions::referencedFullName_optional& transitions::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void transitions::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void transitions::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void transitions::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const transitions::sourceElementId_optional& transitions::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  transitions::sourceElementId_optional& transitions::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void transitions::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void transitions::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }

  const transitions::type1_optional& transitions::
  type1 () const
  {
    return this->type1_;
  }

  transitions::type1_optional& transitions::
  type1 ()
  {
    return this->type1_;
  }

  void transitions::
  type1 (const type1_type& x)
  {
    this->type1_.set (x);
  }

  void transitions::
  type1 (const type1_optional& x)
  {
    this->type1_ = x;
  }

  void transitions::
  type1 (::std::auto_ptr< type1_type > x)
  {
    this->type1_.set (x);
  }


  // guard
  // 

  const guard::leftArgument_sequence& guard::
  leftArgument () const
  {
    return this->leftArgument_;
  }

  guard::leftArgument_sequence& guard::
  leftArgument ()
  {
    return this->leftArgument_;
  }

  void guard::
  leftArgument (const leftArgument_sequence& s)
  {
    this->leftArgument_ = s;
  }

  const guard::rightArgument_sequence& guard::
  rightArgument () const
  {
    return this->rightArgument_;
  }

  guard::rightArgument_sequence& guard::
  rightArgument ()
  {
    return this->rightArgument_;
  }

  void guard::
  rightArgument (const rightArgument_sequence& s)
  {
    this->rightArgument_ = s;
  }

  const guard::type_optional& guard::
  type () const
  {
    return this->type_;
  }

  guard::type_optional& guard::
  type ()
  {
    return this->type_;
  }

  void guard::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void guard::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void guard::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const guard::id_type& guard::
  id () const
  {
    return this->id_.get ();
  }

  guard::id_type& guard::
  id ()
  {
    return this->id_.get ();
  }

  void guard::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void guard::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const guard::externalID_optional& guard::
  externalID () const
  {
    return this->externalID_;
  }

  guard::externalID_optional& guard::
  externalID ()
  {
    return this->externalID_;
  }

  void guard::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void guard::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void guard::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const guard::isFixedName_optional& guard::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  guard::isFixedName_optional& guard::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void guard::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void guard::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const guard::name_type& guard::
  name () const
  {
    return this->name_.get ();
  }

  guard::name_type& guard::
  name ()
  {
    return this->name_.get ();
  }

  void guard::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void guard::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const guard::operator_optional& guard::
  operator_ () const
  {
    return this->operator__;
  }

  guard::operator_optional& guard::
  operator_ ()
  {
    return this->operator__;
  }

  void guard::
  operator_ (const operator_type& x)
  {
    this->operator__.set (x);
  }

  void guard::
  operator_ (const operator_optional& x)
  {
    this->operator__ = x;
  }

  void guard::
  operator_ (::std::auto_ptr< operator_type > x)
  {
    this->operator__.set (x);
  }

  const guard::originalFullName_optional& guard::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  guard::originalFullName_optional& guard::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void guard::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void guard::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void guard::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const guard::originalName_optional& guard::
  originalName () const
  {
    return this->originalName_;
  }

  guard::originalName_optional& guard::
  originalName ()
  {
    return this->originalName_;
  }

  void guard::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void guard::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void guard::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const guard::referencedFullName_optional& guard::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  guard::referencedFullName_optional& guard::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void guard::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void guard::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void guard::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const guard::sourceAction_optional& guard::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  guard::sourceAction_optional& guard::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void guard::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void guard::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void guard::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const guard::sourceElementId_optional& guard::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  guard::sourceElementId_optional& guard::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void guard::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void guard::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // states
  // 

  const states::duringActions_sequence& states::
  duringActions () const
  {
    return this->duringActions_;
  }

  states::duringActions_sequence& states::
  duringActions ()
  {
    return this->duringActions_;
  }

  void states::
  duringActions (const duringActions_sequence& s)
  {
    this->duringActions_ = s;
  }

  const states::outerTransitions_sequence& states::
  outerTransitions () const
  {
    return this->outerTransitions_;
  }

  states::outerTransitions_sequence& states::
  outerTransitions ()
  {
    return this->outerTransitions_;
  }

  void states::
  outerTransitions (const outerTransitions_sequence& s)
  {
    this->outerTransitions_ = s;
  }

  const states::type_optional& states::
  type () const
  {
    return this->type_;
  }

  states::type_optional& states::
  type ()
  {
    return this->type_;
  }

  void states::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void states::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void states::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const states::id_type& states::
  id () const
  {
    return this->id_.get ();
  }

  states::id_type& states::
  id ()
  {
    return this->id_.get ();
  }

  void states::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void states::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const states::executionOrder_optional& states::
  executionOrder () const
  {
    return this->executionOrder_;
  }

  states::executionOrder_optional& states::
  executionOrder ()
  {
    return this->executionOrder_;
  }

  void states::
  executionOrder (const executionOrder_type& x)
  {
    this->executionOrder_.set (x);
  }

  void states::
  executionOrder (const executionOrder_optional& x)
  {
    this->executionOrder_ = x;
  }

  const states::externalID_optional& states::
  externalID () const
  {
    return this->externalID_;
  }

  states::externalID_optional& states::
  externalID ()
  {
    return this->externalID_;
  }

  void states::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void states::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void states::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const states::isFixedName_optional& states::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  states::isFixedName_optional& states::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void states::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void states::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const states::machineType_optional& states::
  machineType () const
  {
    return this->machineType_;
  }

  states::machineType_optional& states::
  machineType ()
  {
    return this->machineType_;
  }

  void states::
  machineType (const machineType_type& x)
  {
    this->machineType_.set (x);
  }

  void states::
  machineType (const machineType_optional& x)
  {
    this->machineType_ = x;
  }

  void states::
  machineType (::std::auto_ptr< machineType_type > x)
  {
    this->machineType_.set (x);
  }

  const states::name_type& states::
  name () const
  {
    return this->name_.get ();
  }

  states::name_type& states::
  name ()
  {
    return this->name_.get ();
  }

  void states::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void states::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const states::originalFullName_optional& states::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  states::originalFullName_optional& states::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void states::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void states::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void states::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const states::originalName_optional& states::
  originalName () const
  {
    return this->originalName_;
  }

  states::originalName_optional& states::
  originalName ()
  {
    return this->originalName_;
  }

  void states::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void states::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void states::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const states::referencedFullName_optional& states::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  states::referencedFullName_optional& states::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void states::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void states::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void states::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const states::sourceElementId_optional& states::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  states::sourceElementId_optional& states::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void states::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void states::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }

  const states::type1_optional& states::
  type1 () const
  {
    return this->type1_;
  }

  states::type1_optional& states::
  type1 ()
  {
    return this->type1_;
  }

  void states::
  type1 (const type1_type& x)
  {
    this->type1_.set (x);
  }

  void states::
  type1 (const type1_optional& x)
  {
    this->type1_ = x;
  }

  void states::
  type1 (::std::auto_ptr< type1_type > x)
  {
    this->type1_.set (x);
  }


  // duringActions
  // 

  const duringActions::operation_sequence& duringActions::
  operation () const
  {
    return this->operation_;
  }

  duringActions::operation_sequence& duringActions::
  operation ()
  {
    return this->operation_;
  }

  void duringActions::
  operation (const operation_sequence& s)
  {
    this->operation_ = s;
  }

  const duringActions::type_optional& duringActions::
  type () const
  {
    return this->type_;
  }

  duringActions::type_optional& duringActions::
  type ()
  {
    return this->type_;
  }

  void duringActions::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void duringActions::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void duringActions::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const duringActions::id_type& duringActions::
  id () const
  {
    return this->id_.get ();
  }

  duringActions::id_type& duringActions::
  id ()
  {
    return this->id_.get ();
  }

  void duringActions::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void duringActions::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const duringActions::externalID_optional& duringActions::
  externalID () const
  {
    return this->externalID_;
  }

  duringActions::externalID_optional& duringActions::
  externalID ()
  {
    return this->externalID_;
  }

  void duringActions::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void duringActions::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void duringActions::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const duringActions::isFixedName_optional& duringActions::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  duringActions::isFixedName_optional& duringActions::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void duringActions::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void duringActions::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const duringActions::name_type& duringActions::
  name () const
  {
    return this->name_.get ();
  }

  duringActions::name_type& duringActions::
  name ()
  {
    return this->name_.get ();
  }

  void duringActions::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void duringActions::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const duringActions::originalFullName_optional& duringActions::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  duringActions::originalFullName_optional& duringActions::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void duringActions::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void duringActions::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void duringActions::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const duringActions::originalName_optional& duringActions::
  originalName () const
  {
    return this->originalName_;
  }

  duringActions::originalName_optional& duringActions::
  originalName ()
  {
    return this->originalName_;
  }

  void duringActions::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void duringActions::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void duringActions::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const duringActions::referencedFullName_optional& duringActions::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  duringActions::referencedFullName_optional& duringActions::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void duringActions::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void duringActions::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void duringActions::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const duringActions::sourceElementId_optional& duringActions::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  duringActions::sourceElementId_optional& duringActions::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void duringActions::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void duringActions::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // operation
  // 

  const operation::leftExpression_sequence& operation::
  leftExpression () const
  {
    return this->leftExpression_;
  }

  operation::leftExpression_sequence& operation::
  leftExpression ()
  {
    return this->leftExpression_;
  }

  void operation::
  leftExpression (const leftExpression_sequence& s)
  {
    this->leftExpression_ = s;
  }

  const operation::rightExpression_sequence& operation::
  rightExpression () const
  {
    return this->rightExpression_;
  }

  operation::rightExpression_sequence& operation::
  rightExpression ()
  {
    return this->rightExpression_;
  }

  void operation::
  rightExpression (const rightExpression_sequence& s)
  {
    this->rightExpression_ = s;
  }

  const operation::type_optional& operation::
  type () const
  {
    return this->type_;
  }

  operation::type_optional& operation::
  type ()
  {
    return this->type_;
  }

  void operation::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void operation::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void operation::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const operation::id_type& operation::
  id () const
  {
    return this->id_.get ();
  }

  operation::id_type& operation::
  id ()
  {
    return this->id_.get ();
  }

  void operation::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void operation::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const operation::externalID_optional& operation::
  externalID () const
  {
    return this->externalID_;
  }

  operation::externalID_optional& operation::
  externalID ()
  {
    return this->externalID_;
  }

  void operation::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void operation::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void operation::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const operation::isFixedName_optional& operation::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  operation::isFixedName_optional& operation::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void operation::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void operation::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const operation::name_type& operation::
  name () const
  {
    return this->name_.get ();
  }

  operation::name_type& operation::
  name ()
  {
    return this->name_.get ();
  }

  void operation::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void operation::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const operation::operator_optional& operation::
  operator_ () const
  {
    return this->operator__;
  }

  operation::operator_optional& operation::
  operator_ ()
  {
    return this->operator__;
  }

  void operation::
  operator_ (const operator_type& x)
  {
    this->operator__.set (x);
  }

  void operation::
  operator_ (const operator_optional& x)
  {
    this->operator__ = x;
  }

  void operation::
  operator_ (::std::auto_ptr< operator_type > x)
  {
    this->operator__.set (x);
  }

  const operation::originalFullName_optional& operation::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  operation::originalFullName_optional& operation::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void operation::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void operation::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void operation::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const operation::originalName_optional& operation::
  originalName () const
  {
    return this->originalName_;
  }

  operation::originalName_optional& operation::
  originalName ()
  {
    return this->originalName_;
  }

  void operation::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void operation::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void operation::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const operation::referencedFullName_optional& operation::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  operation::referencedFullName_optional& operation::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void operation::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void operation::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void operation::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const operation::saturation_optional& operation::
  saturation () const
  {
    return this->saturation_;
  }

  operation::saturation_optional& operation::
  saturation ()
  {
    return this->saturation_;
  }

  void operation::
  saturation (const saturation_type& x)
  {
    this->saturation_.set (x);
  }

  void operation::
  saturation (const saturation_optional& x)
  {
    this->saturation_ = x;
  }

  void operation::
  saturation (::std::auto_ptr< saturation_type > x)
  {
    this->saturation_.set (x);
  }

  const operation::sequenceNumber_optional& operation::
  sequenceNumber () const
  {
    return this->sequenceNumber_;
  }

  operation::sequenceNumber_optional& operation::
  sequenceNumber ()
  {
    return this->sequenceNumber_;
  }

  void operation::
  sequenceNumber (const sequenceNumber_type& x)
  {
    this->sequenceNumber_.set (x);
  }

  void operation::
  sequenceNumber (const sequenceNumber_optional& x)
  {
    this->sequenceNumber_ = x;
  }

  const operation::sourceAction_optional& operation::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  operation::sourceAction_optional& operation::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void operation::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void operation::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void operation::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const operation::sourceElementId_optional& operation::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  operation::sourceElementId_optional& operation::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void operation::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void operation::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // sideExpression
  // 

  const sideExpression::argument_sequence& sideExpression::
  argument () const
  {
    return this->argument_;
  }

  sideExpression::argument_sequence& sideExpression::
  argument ()
  {
    return this->argument_;
  }

  void sideExpression::
  argument (const argument_sequence& s)
  {
    this->argument_ = s;
  }

  const sideExpression::type_optional& sideExpression::
  type () const
  {
    return this->type_;
  }

  sideExpression::type_optional& sideExpression::
  type ()
  {
    return this->type_;
  }

  void sideExpression::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void sideExpression::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void sideExpression::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const sideExpression::id_type& sideExpression::
  id () const
  {
    return this->id_.get ();
  }

  sideExpression::id_type& sideExpression::
  id ()
  {
    return this->id_.get ();
  }

  void sideExpression::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void sideExpression::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const sideExpression::externalID_optional& sideExpression::
  externalID () const
  {
    return this->externalID_;
  }

  sideExpression::externalID_optional& sideExpression::
  externalID ()
  {
    return this->externalID_;
  }

  void sideExpression::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void sideExpression::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void sideExpression::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const sideExpression::isFixedName_optional& sideExpression::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  sideExpression::isFixedName_optional& sideExpression::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void sideExpression::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void sideExpression::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const sideExpression::name_type& sideExpression::
  name () const
  {
    return this->name_.get ();
  }

  sideExpression::name_type& sideExpression::
  name ()
  {
    return this->name_.get ();
  }

  void sideExpression::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void sideExpression::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const sideExpression::originalFullName_optional& sideExpression::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  sideExpression::originalFullName_optional& sideExpression::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void sideExpression::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void sideExpression::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void sideExpression::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const sideExpression::originalName_optional& sideExpression::
  originalName () const
  {
    return this->originalName_;
  }

  sideExpression::originalName_optional& sideExpression::
  originalName ()
  {
    return this->originalName_;
  }

  void sideExpression::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void sideExpression::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void sideExpression::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const sideExpression::referencedFullName_optional& sideExpression::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  sideExpression::referencedFullName_optional& sideExpression::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void sideExpression::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void sideExpression::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void sideExpression::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const sideExpression::sourceAction_optional& sideExpression::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  sideExpression::sourceAction_optional& sideExpression::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void sideExpression::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void sideExpression::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void sideExpression::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const sideExpression::sourceElementId_optional& sideExpression::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  sideExpression::sourceElementId_optional& sideExpression::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void sideExpression::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void sideExpression::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // outerTransitions
  // 

  const outerTransitions::guard_sequence& outerTransitions::
  guard () const
  {
    return this->guard_;
  }

  outerTransitions::guard_sequence& outerTransitions::
  guard ()
  {
    return this->guard_;
  }

  void outerTransitions::
  guard (const guard_sequence& s)
  {
    this->guard_ = s;
  }

  const outerTransitions::type_optional& outerTransitions::
  type () const
  {
    return this->type_;
  }

  outerTransitions::type_optional& outerTransitions::
  type ()
  {
    return this->type_;
  }

  void outerTransitions::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void outerTransitions::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void outerTransitions::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const outerTransitions::id_type& outerTransitions::
  id () const
  {
    return this->id_.get ();
  }

  outerTransitions::id_type& outerTransitions::
  id ()
  {
    return this->id_.get ();
  }

  void outerTransitions::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void outerTransitions::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const outerTransitions::destination_optional& outerTransitions::
  destination () const
  {
    return this->destination_;
  }

  outerTransitions::destination_optional& outerTransitions::
  destination ()
  {
    return this->destination_;
  }

  void outerTransitions::
  destination (const destination_type& x)
  {
    this->destination_.set (x);
  }

  void outerTransitions::
  destination (const destination_optional& x)
  {
    this->destination_ = x;
  }

  const outerTransitions::executionOrder_optional& outerTransitions::
  executionOrder () const
  {
    return this->executionOrder_;
  }

  outerTransitions::executionOrder_optional& outerTransitions::
  executionOrder ()
  {
    return this->executionOrder_;
  }

  void outerTransitions::
  executionOrder (const executionOrder_type& x)
  {
    this->executionOrder_.set (x);
  }

  void outerTransitions::
  executionOrder (const executionOrder_optional& x)
  {
    this->executionOrder_ = x;
  }

  const outerTransitions::externalID_optional& outerTransitions::
  externalID () const
  {
    return this->externalID_;
  }

  outerTransitions::externalID_optional& outerTransitions::
  externalID ()
  {
    return this->externalID_;
  }

  void outerTransitions::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void outerTransitions::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void outerTransitions::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const outerTransitions::isFixedName_optional& outerTransitions::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  outerTransitions::isFixedName_optional& outerTransitions::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void outerTransitions::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void outerTransitions::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const outerTransitions::name_type& outerTransitions::
  name () const
  {
    return this->name_.get ();
  }

  outerTransitions::name_type& outerTransitions::
  name ()
  {
    return this->name_.get ();
  }

  void outerTransitions::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void outerTransitions::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const outerTransitions::originalFullName_optional& outerTransitions::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  outerTransitions::originalFullName_optional& outerTransitions::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void outerTransitions::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void outerTransitions::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void outerTransitions::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const outerTransitions::originalName_optional& outerTransitions::
  originalName () const
  {
    return this->originalName_;
  }

  outerTransitions::originalName_optional& outerTransitions::
  originalName ()
  {
    return this->originalName_;
  }

  void outerTransitions::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void outerTransitions::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void outerTransitions::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const outerTransitions::referencedFullName_optional& outerTransitions::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  outerTransitions::referencedFullName_optional& outerTransitions::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void outerTransitions::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void outerTransitions::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void outerTransitions::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const outerTransitions::sourceElementId_optional& outerTransitions::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  outerTransitions::sourceElementId_optional& outerTransitions::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void outerTransitions::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void outerTransitions::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }

  const outerTransitions::type1_optional& outerTransitions::
  type1 () const
  {
    return this->type1_;
  }

  outerTransitions::type1_optional& outerTransitions::
  type1 ()
  {
    return this->type1_;
  }

  void outerTransitions::
  type1 (const type1_type& x)
  {
    this->type1_.set (x);
  }

  void outerTransitions::
  type1 (const type1_optional& x)
  {
    this->type1_ = x;
  }

  void outerTransitions::
  type1 (::std::auto_ptr< type1_type > x)
  {
    this->type1_.set (x);
  }


  // customTypes
  // 

  const customTypes::members_sequence& customTypes::
  members () const
  {
    return this->members_;
  }

  customTypes::members_sequence& customTypes::
  members ()
  {
    return this->members_;
  }

  void customTypes::
  members (const members_sequence& s)
  {
    this->members_ = s;
  }

  const customTypes::type_optional& customTypes::
  type () const
  {
    return this->type_;
  }

  customTypes::type_optional& customTypes::
  type ()
  {
    return this->type_;
  }

  void customTypes::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void customTypes::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void customTypes::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const customTypes::id_type& customTypes::
  id () const
  {
    return this->id_.get ();
  }

  customTypes::id_type& customTypes::
  id ()
  {
    return this->id_.get ();
  }

  void customTypes::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void customTypes::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const customTypes::alias_optional& customTypes::
  alias () const
  {
    return this->alias_;
  }

  customTypes::alias_optional& customTypes::
  alias ()
  {
    return this->alias_;
  }

  void customTypes::
  alias (const alias_type& x)
  {
    this->alias_.set (x);
  }

  void customTypes::
  alias (const alias_optional& x)
  {
    this->alias_ = x;
  }

  void customTypes::
  alias (::std::auto_ptr< alias_type > x)
  {
    this->alias_.set (x);
  }

  const customTypes::externalID_optional& customTypes::
  externalID () const
  {
    return this->externalID_;
  }

  customTypes::externalID_optional& customTypes::
  externalID ()
  {
    return this->externalID_;
  }

  void customTypes::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void customTypes::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void customTypes::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const customTypes::isFixedName_optional& customTypes::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  customTypes::isFixedName_optional& customTypes::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void customTypes::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void customTypes::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const customTypes::isUnion_optional& customTypes::
  isUnion () const
  {
    return this->isUnion_;
  }

  customTypes::isUnion_optional& customTypes::
  isUnion ()
  {
    return this->isUnion_;
  }

  void customTypes::
  isUnion (const isUnion_type& x)
  {
    this->isUnion_.set (x);
  }

  void customTypes::
  isUnion (const isUnion_optional& x)
  {
    this->isUnion_ = x;
  }

  const customTypes::name_type& customTypes::
  name () const
  {
    return this->name_.get ();
  }

  customTypes::name_type& customTypes::
  name ()
  {
    return this->name_.get ();
  }

  void customTypes::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void customTypes::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const customTypes::originalFullName_optional& customTypes::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  customTypes::originalFullName_optional& customTypes::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void customTypes::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void customTypes::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void customTypes::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const customTypes::originalName_optional& customTypes::
  originalName () const
  {
    return this->originalName_;
  }

  customTypes::originalName_optional& customTypes::
  originalName ()
  {
    return this->originalName_;
  }

  void customTypes::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void customTypes::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void customTypes::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const customTypes::referencedFullName_optional& customTypes::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  customTypes::referencedFullName_optional& customTypes::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void customTypes::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void customTypes::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void customTypes::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const customTypes::scope_optional& customTypes::
  scope () const
  {
    return this->scope_;
  }

  customTypes::scope_optional& customTypes::
  scope ()
  {
    return this->scope_;
  }

  void customTypes::
  scope (const scope_type& x)
  {
    this->scope_.set (x);
  }

  void customTypes::
  scope (const scope_optional& x)
  {
    this->scope_ = x;
  }

  void customTypes::
  scope (::std::auto_ptr< scope_type > x)
  {
    this->scope_.set (x);
  }

  const customTypes::sourceAction_optional& customTypes::
  sourceAction () const
  {
    return this->sourceAction_;
  }

  customTypes::sourceAction_optional& customTypes::
  sourceAction ()
  {
    return this->sourceAction_;
  }

  void customTypes::
  sourceAction (const sourceAction_type& x)
  {
    this->sourceAction_.set (x);
  }

  void customTypes::
  sourceAction (const sourceAction_optional& x)
  {
    this->sourceAction_ = x;
  }

  void customTypes::
  sourceAction (::std::auto_ptr< sourceAction_type > x)
  {
    this->sourceAction_.set (x);
  }

  const customTypes::sourceElementId_optional& customTypes::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  customTypes::sourceElementId_optional& customTypes::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void customTypes::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void customTypes::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }


  // members
  // 

  const members::dataType_sequence& members::
  dataType () const
  {
    return this->dataType_;
  }

  members::dataType_sequence& members::
  dataType ()
  {
    return this->dataType_;
  }

  void members::
  dataType (const dataType_sequence& s)
  {
    this->dataType_ = s;
  }

  const members::type_optional& members::
  type () const
  {
    return this->type_;
  }

  members::type_optional& members::
  type ()
  {
    return this->type_;
  }

  void members::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void members::
  type (const type_optional& x)
  {
    this->type_ = x;
  }

  void members::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const members::id_type& members::
  id () const
  {
    return this->id_.get ();
  }

  members::id_type& members::
  id ()
  {
    return this->id_.get ();
  }

  void members::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void members::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const members::externalID_optional& members::
  externalID () const
  {
    return this->externalID_;
  }

  members::externalID_optional& members::
  externalID ()
  {
    return this->externalID_;
  }

  void members::
  externalID (const externalID_type& x)
  {
    this->externalID_.set (x);
  }

  void members::
  externalID (const externalID_optional& x)
  {
    this->externalID_ = x;
  }

  void members::
  externalID (::std::auto_ptr< externalID_type > x)
  {
    this->externalID_.set (x);
  }

  const members::isFixedName_optional& members::
  isFixedName () const
  {
    return this->isFixedName_;
  }

  members::isFixedName_optional& members::
  isFixedName ()
  {
    return this->isFixedName_;
  }

  void members::
  isFixedName (const isFixedName_type& x)
  {
    this->isFixedName_.set (x);
  }

  void members::
  isFixedName (const isFixedName_optional& x)
  {
    this->isFixedName_ = x;
  }

  const members::name_type& members::
  name () const
  {
    return this->name_.get ();
  }

  members::name_type& members::
  name ()
  {
    return this->name_.get ();
  }

  void members::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void members::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const members::originalFullName_optional& members::
  originalFullName () const
  {
    return this->originalFullName_;
  }

  members::originalFullName_optional& members::
  originalFullName ()
  {
    return this->originalFullName_;
  }

  void members::
  originalFullName (const originalFullName_type& x)
  {
    this->originalFullName_.set (x);
  }

  void members::
  originalFullName (const originalFullName_optional& x)
  {
    this->originalFullName_ = x;
  }

  void members::
  originalFullName (::std::auto_ptr< originalFullName_type > x)
  {
    this->originalFullName_.set (x);
  }

  const members::originalName_optional& members::
  originalName () const
  {
    return this->originalName_;
  }

  members::originalName_optional& members::
  originalName ()
  {
    return this->originalName_;
  }

  void members::
  originalName (const originalName_type& x)
  {
    this->originalName_.set (x);
  }

  void members::
  originalName (const originalName_optional& x)
  {
    this->originalName_ = x;
  }

  void members::
  originalName (::std::auto_ptr< originalName_type > x)
  {
    this->originalName_.set (x);
  }

  const members::referencedFullName_optional& members::
  referencedFullName () const
  {
    return this->referencedFullName_;
  }

  members::referencedFullName_optional& members::
  referencedFullName ()
  {
    return this->referencedFullName_;
  }

  void members::
  referencedFullName (const referencedFullName_type& x)
  {
    this->referencedFullName_.set (x);
  }

  void members::
  referencedFullName (const referencedFullName_optional& x)
  {
    this->referencedFullName_ = x;
  }

  void members::
  referencedFullName (::std::auto_ptr< referencedFullName_type > x)
  {
    this->referencedFullName_.set (x);
  }

  const members::sourceElementId_optional& members::
  sourceElementId () const
  {
    return this->sourceElementId_;
  }

  members::sourceElementId_optional& members::
  sourceElementId ()
  {
    return this->sourceElementId_;
  }

  void members::
  sourceElementId (const sourceElementId_type& x)
  {
    this->sourceElementId_.set (x);
  }

  void members::
  sourceElementId (const sourceElementId_optional& x)
  {
    this->sourceElementId_ = x;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace QGenXMI
{
  // id_list
  //

  id_list::
  id_list (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (e, f, this)
  {
  }

  id_list::
  id_list (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (a, f, this)
  {
  }

  id_list::
  id_list (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::simple_type (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::int_, char > (s, e, f, this)
  {
  }

  id_list* id_list::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class id_list (*this, f, c);
  }

  id_list::
  ~id_list ()
  {
  }

  // valuetype
  //

  valuetype::
  valuetype (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  valuetype::
  valuetype (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  valuetype::
  valuetype (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  valuetype* valuetype::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class valuetype (*this, f, c);
  }

  // model
  //

  model::
  model (const elements_type& elements,
         const id_type& id,
         const modelName_type& modelName)
  : ::xml_schema::type (),
    elements_ (elements, this),
    orphans_ (this),
    id_ (id, this),
    fixedStep_ (this),
    lastId_ (this),
    lastSavedBy_ (this),
    lastSavedOn_ (this),
    modelName_ (modelName, this),
    modelVersion_ (this),
    noNewId_ (this),
    taskingType_ (this)
  {
  }

  model::
  model (::std::auto_ptr< elements_type > elements,
         const id_type& id,
         const modelName_type& modelName)
  : ::xml_schema::type (),
    elements_ (elements, this),
    orphans_ (this),
    id_ (id, this),
    fixedStep_ (this),
    lastId_ (this),
    lastSavedBy_ (this),
    lastSavedOn_ (this),
    modelName_ (modelName, this),
    modelVersion_ (this),
    noNewId_ (this),
    taskingType_ (this)
  {
  }

  model::
  model (const model& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    elements_ (x.elements_, f, this),
    orphans_ (x.orphans_, f, this),
    id_ (x.id_, f, this),
    fixedStep_ (x.fixedStep_, f, this),
    lastId_ (x.lastId_, f, this),
    lastSavedBy_ (x.lastSavedBy_, f, this),
    lastSavedOn_ (x.lastSavedOn_, f, this),
    modelName_ (x.modelName_, f, this),
    modelVersion_ (x.modelVersion_, f, this),
    noNewId_ (x.noNewId_, f, this),
    taskingType_ (x.taskingType_, f, this)
  {
  }

  model::
  model (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    elements_ (this),
    orphans_ (this),
    id_ (this),
    fixedStep_ (this),
    lastId_ (this),
    lastSavedBy_ (this),
    lastSavedOn_ (this),
    modelName_ (this),
    modelVersion_ (this),
    noNewId_ (this),
    taskingType_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void model::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // elements
      //
      if (n.name () == "elements" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< elements_type > r (
          elements_traits::create (i, f, this));

        if (!elements_.present ())
        {
          this->elements_.set (r);
          continue;
        }
      }

      // orphans
      //
      if (n.name () == "orphans" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< orphans_type > r (
          orphans_traits::create (i, f, this));

        this->orphans_.push_back (r);
        continue;
      }

      break;
    }

    if (!elements_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "elements",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fixedStep" && n.namespace_ ().empty ())
      {
        this->fixedStep_.set (fixedStep_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lastId" && n.namespace_ ().empty ())
      {
        this->lastId_.set (lastId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lastSavedBy" && n.namespace_ ().empty ())
      {
        this->lastSavedBy_.set (lastSavedBy_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "lastSavedOn" && n.namespace_ ().empty ())
      {
        this->lastSavedOn_.set (lastSavedOn_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "modelName" && n.namespace_ ().empty ())
      {
        this->modelName_.set (modelName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "modelVersion" && n.namespace_ ().empty ())
      {
        this->modelVersion_.set (modelVersion_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "noNewId" && n.namespace_ ().empty ())
      {
        this->noNewId_.set (noNewId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "taskingType" && n.namespace_ ().empty ())
      {
        this->taskingType_.set (taskingType_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!modelName_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "modelName",
        "");
    }
  }

  model* model::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class model (*this, f, c);
  }

  model& model::
  operator= (const model& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->elements_ = x.elements_;
      this->orphans_ = x.orphans_;
      this->id_ = x.id_;
      this->fixedStep_ = x.fixedStep_;
      this->lastId_ = x.lastId_;
      this->lastSavedBy_ = x.lastSavedBy_;
      this->lastSavedOn_ = x.lastSavedOn_;
      this->modelName_ = x.modelName_;
      this->modelVersion_ = x.modelVersion_;
      this->noNewId_ = x.noNewId_;
      this->taskingType_ = x.taskingType_;
    }

    return *this;
  }

  model::
  ~model ()
  {
  }

  // elements
  //

  elements::
  elements (const id_type& id,
            const name_type& name,
            const type1_type& type1)
  : ::xml_schema::type (),
    blocks_ (this),
    customTypes_ (this),
    inDataPorts_ (this),
    outDataPorts_ (this),
    signals_ (this),
    variables_ (this),
    type_ (this),
    id_ (id, this),
    assignedPriority_ (this),
    assignedPrioritySource_ (this),
    executionOrder_ (this),
    externalID_ (this),
    fcnName_ (this),
    isFixedName_ (this),
    isFullyTyped_ (this),
    isReferenceModel_ (this),
    maskType_ (this),
    name_ (name, this),
    offset_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    samplePeriod_ (this),
    sourceBlockName_ (this),
    sourceElementId_ (this),
    style_ (this),
    type1_ (type1, this),
    userDefinedPriority_ (this)
  {
  }

  elements::
  elements (const elements& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    blocks_ (x.blocks_, f, this),
    customTypes_ (x.customTypes_, f, this),
    inDataPorts_ (x.inDataPorts_, f, this),
    outDataPorts_ (x.outDataPorts_, f, this),
    signals_ (x.signals_, f, this),
    variables_ (x.variables_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    assignedPriority_ (x.assignedPriority_, f, this),
    assignedPrioritySource_ (x.assignedPrioritySource_, f, this),
    executionOrder_ (x.executionOrder_, f, this),
    externalID_ (x.externalID_, f, this),
    fcnName_ (x.fcnName_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    isFullyTyped_ (x.isFullyTyped_, f, this),
    isReferenceModel_ (x.isReferenceModel_, f, this),
    maskType_ (x.maskType_, f, this),
    name_ (x.name_, f, this),
    offset_ (x.offset_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    samplePeriod_ (x.samplePeriod_, f, this),
    sourceBlockName_ (x.sourceBlockName_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this),
    style_ (x.style_, f, this),
    type1_ (x.type1_, f, this),
    userDefinedPriority_ (x.userDefinedPriority_, f, this)
  {
  }

  elements::
  elements (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    blocks_ (this),
    customTypes_ (this),
    inDataPorts_ (this),
    outDataPorts_ (this),
    signals_ (this),
    variables_ (this),
    type_ (this),
    id_ (this),
    assignedPriority_ (this),
    assignedPrioritySource_ (this),
    executionOrder_ (this),
    externalID_ (this),
    fcnName_ (this),
    isFixedName_ (this),
    isFullyTyped_ (this),
    isReferenceModel_ (this),
    maskType_ (this),
    name_ (this),
    offset_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    samplePeriod_ (this),
    sourceBlockName_ (this),
    sourceElementId_ (this),
    style_ (this),
    type1_ (this),
    userDefinedPriority_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void elements::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // blocks
      //
      if (n.name () == "blocks" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< blocks_type > r (
          blocks_traits::create (i, f, this));

        this->blocks_.push_back (r);
        continue;
      }

      // customTypes
      //
      if (n.name () == "customTypes" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< customTypes_type > r (
          customTypes_traits::create (i, f, this));

        this->customTypes_.push_back (r);
        continue;
      }

      // inDataPorts
      //
      if (n.name () == "inDataPorts" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< inDataPorts_type > r (
          inDataPorts_traits::create (i, f, this));

        this->inDataPorts_.push_back (r);
        continue;
      }

      // outDataPorts
      //
      if (n.name () == "outDataPorts" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< outDataPorts_type > r (
          outDataPorts_traits::create (i, f, this));

        this->outDataPorts_.push_back (r);
        continue;
      }

      // signals
      //
      if (n.name () == "signals" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< signals_type > r (
          signals_traits::create (i, f, this));

        this->signals_.push_back (r);
        continue;
      }

      // variables
      //
      if (n.name () == "variables" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< variables_type > r (
          variables_traits::create (i, f, this));

        this->variables_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "assignedPriority" && n.namespace_ ().empty ())
      {
        this->assignedPriority_.set (assignedPriority_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "assignedPrioritySource" && n.namespace_ ().empty ())
      {
        this->assignedPrioritySource_.set (assignedPrioritySource_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "executionOrder" && n.namespace_ ().empty ())
      {
        this->executionOrder_.set (executionOrder_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "fcnName" && n.namespace_ ().empty ())
      {
        this->fcnName_.set (fcnName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFullyTyped" && n.namespace_ ().empty ())
      {
        this->isFullyTyped_.set (isFullyTyped_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isReferenceModel" && n.namespace_ ().empty ())
      {
        this->isReferenceModel_.set (isReferenceModel_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maskType" && n.namespace_ ().empty ())
      {
        this->maskType_.set (maskType_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "offset" && n.namespace_ ().empty ())
      {
        this->offset_.set (offset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "samplePeriod" && n.namespace_ ().empty ())
      {
        this->samplePeriod_.set (samplePeriod_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceBlockName" && n.namespace_ ().empty ())
      {
        this->sourceBlockName_.set (sourceBlockName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "style" && n.namespace_ ().empty ())
      {
        this->style_.set (style_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type1_.set (type1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "userDefinedPriority" && n.namespace_ ().empty ())
      {
        this->userDefinedPriority_.set (userDefinedPriority_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!type1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  elements* elements::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class elements (*this, f, c);
  }

  elements& elements::
  operator= (const elements& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->blocks_ = x.blocks_;
      this->customTypes_ = x.customTypes_;
      this->inDataPorts_ = x.inDataPorts_;
      this->outDataPorts_ = x.outDataPorts_;
      this->signals_ = x.signals_;
      this->variables_ = x.variables_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->assignedPriority_ = x.assignedPriority_;
      this->assignedPrioritySource_ = x.assignedPrioritySource_;
      this->executionOrder_ = x.executionOrder_;
      this->externalID_ = x.externalID_;
      this->fcnName_ = x.fcnName_;
      this->isFixedName_ = x.isFixedName_;
      this->isFullyTyped_ = x.isFullyTyped_;
      this->isReferenceModel_ = x.isReferenceModel_;
      this->maskType_ = x.maskType_;
      this->name_ = x.name_;
      this->offset_ = x.offset_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->samplePeriod_ = x.samplePeriod_;
      this->sourceBlockName_ = x.sourceBlockName_;
      this->sourceElementId_ = x.sourceElementId_;
      this->style_ = x.style_;
      this->type1_ = x.type1_;
      this->userDefinedPriority_ = x.userDefinedPriority_;
    }

    return *this;
  }

  elements::
  ~elements ()
  {
  }

  // blocks
  //

  blocks::
  blocks (const id_type& id,
          const name_type& name,
          const type1_type& type1)
  : ::xml_schema::type (),
    blocks1_ (this),
    inDataPorts_ (this),
    inEdgeEnablePort_ (this),
    inEnablePort_ (this),
    outDataPorts_ (this),
    parameters_ (this),
    signals_ (this),
    inControlPort_ (this),
    outControlPorts_ (this),
    composition_ (this),
    type_ (this),
    id_ (id, this),
    assignedPriority_ (this),
    assignedPrioritySource_ (this),
    executionOrder_ (this),
    externalID_ (this),
    isFixedName_ (this),
    isFullyTyped_ (this),
    maskType_ (this),
    name_ (name, this),
    offset_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    samplePeriod_ (this),
    sourceBlockName_ (this),
    sourceElementId_ (this),
    type1_ (type1, this),
    userDefinedPriority_ (this)
  {
  }

  blocks::
  blocks (const blocks& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    blocks1_ (x.blocks1_, f, this),
    inDataPorts_ (x.inDataPorts_, f, this),
    inEdgeEnablePort_ (x.inEdgeEnablePort_, f, this),
    inEnablePort_ (x.inEnablePort_, f, this),
    outDataPorts_ (x.outDataPorts_, f, this),
    parameters_ (x.parameters_, f, this),
    signals_ (x.signals_, f, this),
    inControlPort_ (x.inControlPort_, f, this),
    outControlPorts_ (x.outControlPorts_, f, this),
    composition_ (x.composition_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    assignedPriority_ (x.assignedPriority_, f, this),
    assignedPrioritySource_ (x.assignedPrioritySource_, f, this),
    executionOrder_ (x.executionOrder_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    isFullyTyped_ (x.isFullyTyped_, f, this),
    maskType_ (x.maskType_, f, this),
    name_ (x.name_, f, this),
    offset_ (x.offset_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    samplePeriod_ (x.samplePeriod_, f, this),
    sourceBlockName_ (x.sourceBlockName_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this),
    type1_ (x.type1_, f, this),
    userDefinedPriority_ (x.userDefinedPriority_, f, this)
  {
  }

  blocks::
  blocks (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    blocks1_ (this),
    inDataPorts_ (this),
    inEdgeEnablePort_ (this),
    inEnablePort_ (this),
    outDataPorts_ (this),
    parameters_ (this),
    signals_ (this),
    inControlPort_ (this),
    outControlPorts_ (this),
    composition_ (this),
    type_ (this),
    id_ (this),
    assignedPriority_ (this),
    assignedPrioritySource_ (this),
    executionOrder_ (this),
    externalID_ (this),
    isFixedName_ (this),
    isFullyTyped_ (this),
    maskType_ (this),
    name_ (this),
    offset_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    samplePeriod_ (this),
    sourceBlockName_ (this),
    sourceElementId_ (this),
    type1_ (this),
    userDefinedPriority_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void blocks::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // blocks
      //
      if (n.name () == "blocks" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< blocks1_type > r (
          blocks1_traits::create (i, f, this));

        this->blocks1_.push_back (r);
        continue;
      }

      // inDataPorts
      //
      if (n.name () == "inDataPorts" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< inDataPorts_type > r (
          inDataPorts_traits::create (i, f, this));

        this->inDataPorts_.push_back (r);
        continue;
      }

      // inEdgeEnablePort
      //
      if (n.name () == "inEdgeEnablePort" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< inEdgeEnablePort_type > r (
          inEdgeEnablePort_traits::create (i, f, this));

        if (!this->inEdgeEnablePort_)
        {
          this->inEdgeEnablePort_.set (r);
          continue;
        }
      }

      // inEnablePort
      //
      if (n.name () == "inEnablePort" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< inEnablePort_type > r (
          inEnablePort_traits::create (i, f, this));

        if (!this->inEnablePort_)
        {
          this->inEnablePort_.set (r);
          continue;
        }
      }

      // outDataPorts
      //
      if (n.name () == "outDataPorts" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< outDataPorts_type > r (
          outDataPorts_traits::create (i, f, this));

        this->outDataPorts_.push_back (r);
        continue;
      }

      // parameters
      //
      if (n.name () == "parameters" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< parameters_type > r (
          parameters_traits::create (i, f, this));

        this->parameters_.push_back (r);
        continue;
      }

      // signals
      //
      if (n.name () == "signals" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< signals_type > r (
          signals_traits::create (i, f, this));

        this->signals_.push_back (r);
        continue;
      }

      // inControlPort
      //
      if (n.name () == "inControlPort" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< inControlPort_type > r (
          inControlPort_traits::create (i, f, this));

        if (!this->inControlPort_)
        {
          this->inControlPort_.set (r);
          continue;
        }
      }

      // outControlPorts
      //
      if (n.name () == "outControlPorts" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< outControlPorts_type > r (
          outControlPorts_traits::create (i, f, this));

        this->outControlPorts_.push_back (r);
        continue;
      }

      // composition
      //
      if (n.name () == "composition" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< composition_type > r (
          composition_traits::create (i, f, this));

        this->composition_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "assignedPriority" && n.namespace_ ().empty ())
      {
        this->assignedPriority_.set (assignedPriority_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "assignedPrioritySource" && n.namespace_ ().empty ())
      {
        this->assignedPrioritySource_.set (assignedPrioritySource_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "executionOrder" && n.namespace_ ().empty ())
      {
        this->executionOrder_.set (executionOrder_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFullyTyped" && n.namespace_ ().empty ())
      {
        this->isFullyTyped_.set (isFullyTyped_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "maskType" && n.namespace_ ().empty ())
      {
        this->maskType_.set (maskType_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "offset" && n.namespace_ ().empty ())
      {
        this->offset_.set (offset_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "samplePeriod" && n.namespace_ ().empty ())
      {
        this->samplePeriod_.set (samplePeriod_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceBlockName" && n.namespace_ ().empty ())
      {
        this->sourceBlockName_.set (sourceBlockName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type1_.set (type1_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "userDefinedPriority" && n.namespace_ ().empty ())
      {
        this->userDefinedPriority_.set (userDefinedPriority_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!type1_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  blocks* blocks::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class blocks (*this, f, c);
  }

  blocks& blocks::
  operator= (const blocks& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->blocks1_ = x.blocks1_;
      this->inDataPorts_ = x.inDataPorts_;
      this->inEdgeEnablePort_ = x.inEdgeEnablePort_;
      this->inEnablePort_ = x.inEnablePort_;
      this->outDataPorts_ = x.outDataPorts_;
      this->parameters_ = x.parameters_;
      this->signals_ = x.signals_;
      this->inControlPort_ = x.inControlPort_;
      this->outControlPorts_ = x.outControlPorts_;
      this->composition_ = x.composition_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->assignedPriority_ = x.assignedPriority_;
      this->assignedPrioritySource_ = x.assignedPrioritySource_;
      this->executionOrder_ = x.executionOrder_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->isFullyTyped_ = x.isFullyTyped_;
      this->maskType_ = x.maskType_;
      this->name_ = x.name_;
      this->offset_ = x.offset_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->samplePeriod_ = x.samplePeriod_;
      this->sourceBlockName_ = x.sourceBlockName_;
      this->sourceElementId_ = x.sourceElementId_;
      this->type1_ = x.type1_;
      this->userDefinedPriority_ = x.userDefinedPriority_;
    }

    return *this;
  }

  blocks::
  ~blocks ()
  {
  }

  // inDataPorts
  //

  inDataPorts::
  inDataPorts (const id_type& id,
               const name_type& name,
               const portNumber_type& portNumber)
  : ::xml_schema::type (),
    dataType_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    incomingSignal_ (this),
    isFixedName_ (this),
    isRequiredBySuccessors_ (this),
    isVirtual_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    periodicSampleTime_ (this),
    portNumber_ (portNumber, this),
    referencedFullName_ (this),
    sampleTime_ (this),
    sourceBlock_ (this),
    sourceElementId_ (this),
    statesWhenEnabling_ (this)
  {
  }

  inDataPorts::
  inDataPorts (const inDataPorts& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dataType_ (x.dataType_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    incomingSignal_ (x.incomingSignal_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    isRequiredBySuccessors_ (x.isRequiredBySuccessors_, f, this),
    isVirtual_ (x.isVirtual_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    periodicSampleTime_ (x.periodicSampleTime_, f, this),
    portNumber_ (x.portNumber_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sampleTime_ (x.sampleTime_, f, this),
    sourceBlock_ (x.sourceBlock_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this),
    statesWhenEnabling_ (x.statesWhenEnabling_, f, this)
  {
  }

  inDataPorts::
  inDataPorts (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dataType_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    incomingSignal_ (this),
    isFixedName_ (this),
    isRequiredBySuccessors_ (this),
    isVirtual_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    periodicSampleTime_ (this),
    portNumber_ (this),
    referencedFullName_ (this),
    sampleTime_ (this),
    sourceBlock_ (this),
    sourceElementId_ (this),
    statesWhenEnabling_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void inDataPorts::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dataType
      //
      if (n.name () == "dataType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataType_type > r (
          dataType_traits::create (i, f, this));

        this->dataType_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "incomingSignal" && n.namespace_ ().empty ())
      {
        this->incomingSignal_.set (incomingSignal_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isRequiredBySuccessors" && n.namespace_ ().empty ())
      {
        this->isRequiredBySuccessors_.set (isRequiredBySuccessors_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isVirtual" && n.namespace_ ().empty ())
      {
        this->isVirtual_.set (isVirtual_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "periodicSampleTime" && n.namespace_ ().empty ())
      {
        this->periodicSampleTime_.set (periodicSampleTime_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "portNumber" && n.namespace_ ().empty ())
      {
        this->portNumber_.set (portNumber_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sampleTime" && n.namespace_ ().empty ())
      {
        this->sampleTime_.set (sampleTime_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceBlock" && n.namespace_ ().empty ())
      {
        this->sourceBlock_.set (sourceBlock_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "statesWhenEnabling" && n.namespace_ ().empty ())
      {
        this->statesWhenEnabling_.set (statesWhenEnabling_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!portNumber_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "portNumber",
        "");
    }
  }

  inDataPorts* inDataPorts::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class inDataPorts (*this, f, c);
  }

  inDataPorts& inDataPorts::
  operator= (const inDataPorts& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->dataType_ = x.dataType_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->incomingSignal_ = x.incomingSignal_;
      this->isFixedName_ = x.isFixedName_;
      this->isRequiredBySuccessors_ = x.isRequiredBySuccessors_;
      this->isVirtual_ = x.isVirtual_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->periodicSampleTime_ = x.periodicSampleTime_;
      this->portNumber_ = x.portNumber_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sampleTime_ = x.sampleTime_;
      this->sourceBlock_ = x.sourceBlock_;
      this->sourceElementId_ = x.sourceElementId_;
      this->statesWhenEnabling_ = x.statesWhenEnabling_;
    }

    return *this;
  }

  inDataPorts::
  ~inDataPorts ()
  {
  }

  // outDataPorts
  //

  outDataPorts::
  outDataPorts (const id_type& id,
                const name_type& name,
                const portNumber_type& portNumber)
  : ::xml_schema::type (),
    dataType_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    isVirtual_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    outgoingSignals_ (this),
    portNumber_ (portNumber, this),
    referencedFullName_ (this),
    resetWhenDisabled_ (this),
    sourceBlock_ (this),
    sourceElementId_ (this)
  {
  }

  outDataPorts::
  outDataPorts (const outDataPorts& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dataType_ (x.dataType_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    isVirtual_ (x.isVirtual_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    outgoingSignals_ (x.outgoingSignals_, f, this),
    portNumber_ (x.portNumber_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    resetWhenDisabled_ (x.resetWhenDisabled_, f, this),
    sourceBlock_ (x.sourceBlock_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  outDataPorts::
  outDataPorts (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dataType_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    isVirtual_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    outgoingSignals_ (this),
    portNumber_ (this),
    referencedFullName_ (this),
    resetWhenDisabled_ (this),
    sourceBlock_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void outDataPorts::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dataType
      //
      if (n.name () == "dataType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataType_type > r (
          dataType_traits::create (i, f, this));

        this->dataType_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isVirtual" && n.namespace_ ().empty ())
      {
        this->isVirtual_.set (isVirtual_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "outgoingSignals" && n.namespace_ ().empty ())
      {
        this->outgoingSignals_.set (outgoingSignals_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "portNumber" && n.namespace_ ().empty ())
      {
        this->portNumber_.set (portNumber_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "resetWhenDisabled" && n.namespace_ ().empty ())
      {
        this->resetWhenDisabled_.set (resetWhenDisabled_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceBlock" && n.namespace_ ().empty ())
      {
        this->sourceBlock_.set (sourceBlock_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!portNumber_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "portNumber",
        "");
    }
  }

  outDataPorts* outDataPorts::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class outDataPorts (*this, f, c);
  }

  outDataPorts& outDataPorts::
  operator= (const outDataPorts& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->dataType_ = x.dataType_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->isVirtual_ = x.isVirtual_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->outgoingSignals_ = x.outgoingSignals_;
      this->portNumber_ = x.portNumber_;
      this->referencedFullName_ = x.referencedFullName_;
      this->resetWhenDisabled_ = x.resetWhenDisabled_;
      this->sourceBlock_ = x.sourceBlock_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  outDataPorts::
  ~outDataPorts ()
  {
  }

  // dataType
  //

  dataType::
  dataType (const id_type& id,
            const name_type& name)
  : ::xml_schema::type (),
    initialValue_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    scope_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
  }

  dataType::
  dataType (const dataType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    initialValue_ (x.initialValue_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    scope_ (x.scope_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  dataType::
  dataType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    initialValue_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    scope_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void dataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // initialValue
      //
      if (n.name () == "initialValue" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< initialValue_type > r (
          initialValue_traits::create (i, f, this));

        this->initialValue_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (scope_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  dataType* dataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dataType (*this, f, c);
  }

  dataType& dataType::
  operator= (const dataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->initialValue_ = x.initialValue_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->scope_ = x.scope_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  dataType::
  ~dataType ()
  {
  }

  // initialValue
  //

  initialValue::
  initialValue (const id_type& id,
                const litValue_type& litValue,
                const name_type& name)
  : ::xml_schema::type (),
    valueDataType_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    litValue_ (litValue, this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
  }

  initialValue::
  initialValue (const initialValue& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    valueDataType_ (x.valueDataType_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    litValue_ (x.litValue_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  initialValue::
  initialValue (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    valueDataType_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    litValue_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void initialValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // valueDataType
      //
      if (n.name () == "valueDataType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< valueDataType_type > r (
          valueDataType_traits::create (i, f, this));

        this->valueDataType_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "litValue" && n.namespace_ ().empty ())
      {
        this->litValue_.set (litValue_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!litValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "litValue",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  initialValue* initialValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class initialValue (*this, f, c);
  }

  initialValue& initialValue::
  operator= (const initialValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->valueDataType_ = x.valueDataType_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->litValue_ = x.litValue_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  initialValue::
  ~initialValue ()
  {
  }

  // valueDataType
  //

  valueDataType::
  valueDataType (const id_type& id,
                 const name_type& name)
  : ::xml_schema::type (),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    scope_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
  }

  valueDataType::
  valueDataType (const valueDataType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    scope_ (x.scope_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  valueDataType::
  valueDataType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    scope_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void valueDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (scope_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  valueDataType* valueDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class valueDataType (*this, f, c);
  }

  valueDataType& valueDataType::
  operator= (const valueDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->scope_ = x.scope_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  valueDataType::
  ~valueDataType ()
  {
  }

  // parameters
  //

  parameters::
  parameters (const id_type& id,
              const name_type& name)
  : ::xml_schema::type (),
    value_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    index_ (this),
    isFixedName_ (this),
    isMask_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    scope_ (this),
    sourceAction_ (this),
    sourceElementId_ (this),
    storageClass_ (this)
  {
  }

  parameters::
  parameters (const parameters& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    value_ (x.value_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    index_ (x.index_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    isMask_ (x.isMask_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    scope_ (x.scope_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this),
    storageClass_ (x.storageClass_, f, this)
  {
  }

  parameters::
  parameters (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    value_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    index_ (this),
    isFixedName_ (this),
    isMask_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    scope_ (this),
    sourceAction_ (this),
    sourceElementId_ (this),
    storageClass_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void parameters::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // value
      //
      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        this->value_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "index" && n.namespace_ ().empty ())
      {
        this->index_.set (index_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isMask" && n.namespace_ ().empty ())
      {
        this->isMask_.set (isMask_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (scope_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "storageClass" && n.namespace_ ().empty ())
      {
        this->storageClass_.set (storageClass_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  parameters* parameters::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class parameters (*this, f, c);
  }

  parameters& parameters::
  operator= (const parameters& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->value_ = x.value_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->index_ = x.index_;
      this->isFixedName_ = x.isFixedName_;
      this->isMask_ = x.isMask_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->scope_ = x.scope_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
      this->storageClass_ = x.storageClass_;
    }

    return *this;
  }

  parameters::
  ~parameters ()
  {
  }

  // value
  //

  value::
  value (const id_type& id,
         const name_type& name)
  : ::xml_schema::type (),
    argument_ (this),
    valueDataType_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    litValue_ (this),
    name_ (name, this),
    operator__ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElement_ (this),
    sourceElementId_ (this)
  {
  }

  value::
  value (const value& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    argument_ (x.argument_, f, this),
    valueDataType_ (x.valueDataType_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    litValue_ (x.litValue_, f, this),
    name_ (x.name_, f, this),
    operator__ (x.operator__, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElement_ (x.sourceElement_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  value::
  value (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    argument_ (this),
    valueDataType_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    litValue_ (this),
    name_ (this),
    operator__ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElement_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void value::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // argument
      //
      if (n.name () == "argument" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< argument_type > r (
          argument_traits::create (i, f, this));

        this->argument_.push_back (r);
        continue;
      }

      // valueDataType
      //
      if (n.name () == "valueDataType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< valueDataType_type > r (
          valueDataType_traits::create (i, f, this));

        this->valueDataType_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "litValue" && n.namespace_ ().empty ())
      {
        this->litValue_.set (litValue_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "operator" && n.namespace_ ().empty ())
      {
        this->operator__.set (operator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElement" && n.namespace_ ().empty ())
      {
        this->sourceElement_.set (sourceElement_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  value* value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class value (*this, f, c);
  }

  value& value::
  operator= (const value& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->argument_ = x.argument_;
      this->valueDataType_ = x.valueDataType_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->litValue_ = x.litValue_;
      this->name_ = x.name_;
      this->operator__ = x.operator__;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElement_ = x.sourceElement_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  value::
  ~value ()
  {
  }

  // argument
  //

  argument::
  argument (const id_type& id,
            const name_type& name)
  : ::xml_schema::type (),
    valueDataType_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    litValue_ (this),
    name_ (name, this),
    operator__ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
  }

  argument::
  argument (const argument& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    valueDataType_ (x.valueDataType_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    litValue_ (x.litValue_, f, this),
    name_ (x.name_, f, this),
    operator__ (x.operator__, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  argument::
  argument (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    valueDataType_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    litValue_ (this),
    name_ (this),
    operator__ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void argument::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // valueDataType
      //
      if (n.name () == "valueDataType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< valueDataType_type > r (
          valueDataType_traits::create (i, f, this));

        this->valueDataType_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "litValue" && n.namespace_ ().empty ())
      {
        this->litValue_.set (litValue_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "operator" && n.namespace_ ().empty ())
      {
        this->operator__.set (operator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  argument* argument::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class argument (*this, f, c);
  }

  argument& argument::
  operator= (const argument& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->valueDataType_ = x.valueDataType_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->litValue_ = x.litValue_;
      this->name_ = x.name_;
      this->operator__ = x.operator__;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  argument::
  ~argument ()
  {
  }

  // signals
  //

  signals::
  signals (const id_type& id,
           const name_type& name)
  : ::xml_schema::type (),
    type_ (this),
    id_ (id, this),
    dstPort_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sampleTime_ (this),
    sourceElementId_ (this),
    srcPort_ (this),
    storageClass_ (this)
  {
  }

  signals::
  signals (const signals& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    dstPort_ (x.dstPort_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sampleTime_ (x.sampleTime_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this),
    srcPort_ (x.srcPort_, f, this),
    storageClass_ (x.storageClass_, f, this)
  {
  }

  signals::
  signals (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    id_ (this),
    dstPort_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sampleTime_ (this),
    sourceElementId_ (this),
    srcPort_ (this),
    storageClass_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void signals::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "dstPort" && n.namespace_ ().empty ())
      {
        this->dstPort_.set (dstPort_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sampleTime" && n.namespace_ ().empty ())
      {
        this->sampleTime_.set (sampleTime_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "srcPort" && n.namespace_ ().empty ())
      {
        this->srcPort_.set (srcPort_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "storageClass" && n.namespace_ ().empty ())
      {
        this->storageClass_.set (storageClass_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  signals* signals::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class signals (*this, f, c);
  }

  signals& signals::
  operator= (const signals& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->dstPort_ = x.dstPort_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sampleTime_ = x.sampleTime_;
      this->sourceElementId_ = x.sourceElementId_;
      this->srcPort_ = x.srcPort_;
      this->storageClass_ = x.storageClass_;
    }

    return *this;
  }

  signals::
  ~signals ()
  {
  }

  // variables
  //

  variables::
  variables (const id_type& id,
             const name_type& name)
  : ::xml_schema::type (),
    dataType_ (this),
    type_ (this),
    id_ (id, this),
    autoInit_ (this),
    externalID_ (this),
    isConst_ (this),
    isFixedName_ (this),
    isIterator_ (this),
    isOptimizable_ (this),
    isSignalObject_ (this),
    isStatic_ (this),
    isUnreferenced_ (this),
    isVolatile_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referenceBy_ (this),
    referencedFullName_ (this),
    scope_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
  }

  variables::
  variables (const variables& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dataType_ (x.dataType_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    autoInit_ (x.autoInit_, f, this),
    externalID_ (x.externalID_, f, this),
    isConst_ (x.isConst_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    isIterator_ (x.isIterator_, f, this),
    isOptimizable_ (x.isOptimizable_, f, this),
    isSignalObject_ (x.isSignalObject_, f, this),
    isStatic_ (x.isStatic_, f, this),
    isUnreferenced_ (x.isUnreferenced_, f, this),
    isVolatile_ (x.isVolatile_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referenceBy_ (x.referenceBy_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    scope_ (x.scope_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  variables::
  variables (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dataType_ (this),
    type_ (this),
    id_ (this),
    autoInit_ (this),
    externalID_ (this),
    isConst_ (this),
    isFixedName_ (this),
    isIterator_ (this),
    isOptimizable_ (this),
    isSignalObject_ (this),
    isStatic_ (this),
    isUnreferenced_ (this),
    isVolatile_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referenceBy_ (this),
    referencedFullName_ (this),
    scope_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void variables::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dataType
      //
      if (n.name () == "dataType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataType_type > r (
          dataType_traits::create (i, f, this));

        this->dataType_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "autoInit" && n.namespace_ ().empty ())
      {
        this->autoInit_.set (autoInit_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isConst" && n.namespace_ ().empty ())
      {
        this->isConst_.set (isConst_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isIterator" && n.namespace_ ().empty ())
      {
        this->isIterator_.set (isIterator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isOptimizable" && n.namespace_ ().empty ())
      {
        this->isOptimizable_.set (isOptimizable_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isSignalObject" && n.namespace_ ().empty ())
      {
        this->isSignalObject_.set (isSignalObject_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isStatic" && n.namespace_ ().empty ())
      {
        this->isStatic_.set (isStatic_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isUnreferenced" && n.namespace_ ().empty ())
      {
        this->isUnreferenced_.set (isUnreferenced_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isVolatile" && n.namespace_ ().empty ())
      {
        this->isVolatile_.set (isVolatile_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referenceBy" && n.namespace_ ().empty ())
      {
        this->referenceBy_.set (referenceBy_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (scope_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  variables* variables::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class variables (*this, f, c);
  }

  variables& variables::
  operator= (const variables& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->dataType_ = x.dataType_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->autoInit_ = x.autoInit_;
      this->externalID_ = x.externalID_;
      this->isConst_ = x.isConst_;
      this->isFixedName_ = x.isFixedName_;
      this->isIterator_ = x.isIterator_;
      this->isOptimizable_ = x.isOptimizable_;
      this->isSignalObject_ = x.isSignalObject_;
      this->isStatic_ = x.isStatic_;
      this->isUnreferenced_ = x.isUnreferenced_;
      this->isVolatile_ = x.isVolatile_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referenceBy_ = x.referenceBy_;
      this->referencedFullName_ = x.referencedFullName_;
      this->scope_ = x.scope_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  variables::
  ~variables ()
  {
  }

  // orphans
  //

  orphans::
  orphans (const id_type& id,
           const name_type& name)
  : ::xml_schema::type (),
    valueDataType_ (this),
    argument_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    litValue_ (this),
    name_ (name, this),
    operator__ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this),
    variable_ (this)
  {
  }

  orphans::
  orphans (const orphans& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    valueDataType_ (x.valueDataType_, f, this),
    argument_ (x.argument_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    litValue_ (x.litValue_, f, this),
    name_ (x.name_, f, this),
    operator__ (x.operator__, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this),
    variable_ (x.variable_, f, this)
  {
  }

  orphans::
  orphans (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    valueDataType_ (this),
    argument_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    litValue_ (this),
    name_ (this),
    operator__ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this),
    variable_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void orphans::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // valueDataType
      //
      if (n.name () == "valueDataType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< valueDataType_type > r (
          valueDataType_traits::create (i, f, this));

        this->valueDataType_.push_back (r);
        continue;
      }

      // argument
      //
      if (n.name () == "argument" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< argument_type > r (
          argument_traits::create (i, f, this));

        this->argument_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "litValue" && n.namespace_ ().empty ())
      {
        this->litValue_.set (litValue_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "operator" && n.namespace_ ().empty ())
      {
        this->operator__.set (operator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "variable" && n.namespace_ ().empty ())
      {
        this->variable_.set (variable_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  orphans* orphans::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class orphans (*this, f, c);
  }

  orphans& orphans::
  operator= (const orphans& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->valueDataType_ = x.valueDataType_;
      this->argument_ = x.argument_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->litValue_ = x.litValue_;
      this->name_ = x.name_;
      this->operator__ = x.operator__;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
      this->variable_ = x.variable_;
    }

    return *this;
  }

  orphans::
  ~orphans ()
  {
  }

  // sideArgument
  //

  sideArgument::
  sideArgument (const id_type& id,
                const name_type& name)
  : ::xml_schema::type (),
    expresion_ (this),
    valueDataType_ (this),
    arguments_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this),
    standardFunction_ (this)
  {
  }

  sideArgument::
  sideArgument (const sideArgument& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    expresion_ (x.expresion_, f, this),
    valueDataType_ (x.valueDataType_, f, this),
    arguments_ (x.arguments_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this),
    standardFunction_ (x.standardFunction_, f, this)
  {
  }

  sideArgument::
  sideArgument (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    expresion_ (this),
    valueDataType_ (this),
    arguments_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this),
    standardFunction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void sideArgument::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // expresion
      //
      if (n.name () == "expresion" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< expresion_type > r (
          expresion_traits::create (i, f, this));

        this->expresion_.push_back (r);
        continue;
      }

      // valueDataType
      //
      if (n.name () == "valueDataType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< valueDataType_type > r (
          valueDataType_traits::create (i, f, this));

        this->valueDataType_.push_back (r);
        continue;
      }

      // arguments
      //
      if (n.name () == "arguments" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< arguments_type > r (
          arguments_traits::create (i, f, this));

        this->arguments_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "standardFunction" && n.namespace_ ().empty ())
      {
        this->standardFunction_.set (standardFunction_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  sideArgument* sideArgument::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sideArgument (*this, f, c);
  }

  sideArgument& sideArgument::
  operator= (const sideArgument& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->expresion_ = x.expresion_;
      this->valueDataType_ = x.valueDataType_;
      this->arguments_ = x.arguments_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
      this->standardFunction_ = x.standardFunction_;
    }

    return *this;
  }

  sideArgument::
  ~sideArgument ()
  {
  }

  // expression
  //

  expression::
  expression (const id_type& id,
              const name_type& name)
  : ::xml_schema::type (),
    leftArgument_ (this),
    rightArgument_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    operator__ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
  }

  expression::
  expression (const expression& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    leftArgument_ (x.leftArgument_, f, this),
    rightArgument_ (x.rightArgument_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    operator__ (x.operator__, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  expression::
  expression (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    leftArgument_ (this),
    rightArgument_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    operator__ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void expression::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // leftArgument
      //
      if (n.name () == "leftArgument" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< leftArgument_type > r (
          leftArgument_traits::create (i, f, this));

        this->leftArgument_.push_back (r);
        continue;
      }

      // rightArgument
      //
      if (n.name () == "rightArgument" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< rightArgument_type > r (
          rightArgument_traits::create (i, f, this));

        this->rightArgument_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "operator" && n.namespace_ ().empty ())
      {
        this->operator__.set (operator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  expression* expression::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class expression (*this, f, c);
  }

  expression& expression::
  operator= (const expression& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->leftArgument_ = x.leftArgument_;
      this->rightArgument_ = x.rightArgument_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->operator__ = x.operator__;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  expression::
  ~expression ()
  {
  }

  // composition
  //

  composition::
  composition (const id_type& id,
               const name_type& name)
  : ::xml_schema::type (),
    defaultTransitions_ (this),
    junctions_ (this),
    states_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this)
  {
  }

  composition::
  composition (const composition& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    defaultTransitions_ (x.defaultTransitions_, f, this),
    junctions_ (x.junctions_, f, this),
    states_ (x.states_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  composition::
  composition (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    defaultTransitions_ (this),
    junctions_ (this),
    states_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void composition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // defaultTransitions
      //
      if (n.name () == "defaultTransitions" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< defaultTransitions_type > r (
          defaultTransitions_traits::create (i, f, this));

        this->defaultTransitions_.push_back (r);
        continue;
      }

      // junctions
      //
      if (n.name () == "junctions" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< junctions_type > r (
          junctions_traits::create (i, f, this));

        this->junctions_.push_back (r);
        continue;
      }

      // states
      //
      if (n.name () == "states" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< states_type > r (
          states_traits::create (i, f, this));

        this->states_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  composition* composition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class composition (*this, f, c);
  }

  composition& composition::
  operator= (const composition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->defaultTransitions_ = x.defaultTransitions_;
      this->junctions_ = x.junctions_;
      this->states_ = x.states_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  composition::
  ~composition ()
  {
  }

  // defaultTransitions
  //

  defaultTransitions::
  defaultTransitions (const id_type& id,
                      const name_type& name)
  : ::xml_schema::type (),
    type_ (this),
    id_ (id, this),
    destination_ (this),
    executionOrder_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this),
    type1_ (this)
  {
  }

  defaultTransitions::
  defaultTransitions (const defaultTransitions& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    destination_ (x.destination_, f, this),
    executionOrder_ (x.executionOrder_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this),
    type1_ (x.type1_, f, this)
  {
  }

  defaultTransitions::
  defaultTransitions (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    type_ (this),
    id_ (this),
    destination_ (this),
    executionOrder_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this),
    type1_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void defaultTransitions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "destination" && n.namespace_ ().empty ())
      {
        this->destination_.set (destination_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "executionOrder" && n.namespace_ ().empty ())
      {
        this->executionOrder_.set (executionOrder_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type1_.set (type1_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  defaultTransitions* defaultTransitions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class defaultTransitions (*this, f, c);
  }

  defaultTransitions& defaultTransitions::
  operator= (const defaultTransitions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->destination_ = x.destination_;
      this->executionOrder_ = x.executionOrder_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceElementId_ = x.sourceElementId_;
      this->type1_ = x.type1_;
    }

    return *this;
  }

  defaultTransitions::
  ~defaultTransitions ()
  {
  }

  // junctions
  //

  junctions::
  junctions (const id_type& id,
             const name_type& name)
  : ::xml_schema::type (),
    transitions_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    junctionType_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this)
  {
  }

  junctions::
  junctions (const junctions& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    transitions_ (x.transitions_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    junctionType_ (x.junctionType_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  junctions::
  junctions (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    transitions_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    junctionType_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void junctions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // transitions
      //
      if (n.name () == "transitions" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< transitions_type > r (
          transitions_traits::create (i, f, this));

        this->transitions_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "junctionType" && n.namespace_ ().empty ())
      {
        this->junctionType_.set (junctionType_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  junctions* junctions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class junctions (*this, f, c);
  }

  junctions& junctions::
  operator= (const junctions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->transitions_ = x.transitions_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->junctionType_ = x.junctionType_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  junctions::
  ~junctions ()
  {
  }

  // transitions
  //

  transitions::
  transitions (const id_type& id,
               const name_type& name)
  : ::xml_schema::type (),
    guard_ (this),
    type_ (this),
    id_ (id, this),
    destination_ (this),
    executionOrder_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this),
    type1_ (this)
  {
  }

  transitions::
  transitions (const transitions& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    guard_ (x.guard_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    destination_ (x.destination_, f, this),
    executionOrder_ (x.executionOrder_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this),
    type1_ (x.type1_, f, this)
  {
  }

  transitions::
  transitions (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    guard_ (this),
    type_ (this),
    id_ (this),
    destination_ (this),
    executionOrder_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this),
    type1_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void transitions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // guard
      //
      if (n.name () == "guard" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< guard_type > r (
          guard_traits::create (i, f, this));

        this->guard_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "destination" && n.namespace_ ().empty ())
      {
        this->destination_.set (destination_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "executionOrder" && n.namespace_ ().empty ())
      {
        this->executionOrder_.set (executionOrder_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type1_.set (type1_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  transitions* transitions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class transitions (*this, f, c);
  }

  transitions& transitions::
  operator= (const transitions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->guard_ = x.guard_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->destination_ = x.destination_;
      this->executionOrder_ = x.executionOrder_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceElementId_ = x.sourceElementId_;
      this->type1_ = x.type1_;
    }

    return *this;
  }

  transitions::
  ~transitions ()
  {
  }

  // guard
  //

  guard::
  guard (const id_type& id,
         const name_type& name)
  : ::xml_schema::type (),
    leftArgument_ (this),
    rightArgument_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    operator__ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
  }

  guard::
  guard (const guard& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    leftArgument_ (x.leftArgument_, f, this),
    rightArgument_ (x.rightArgument_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    operator__ (x.operator__, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  guard::
  guard (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    leftArgument_ (this),
    rightArgument_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    operator__ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void guard::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // leftArgument
      //
      if (n.name () == "leftArgument" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< leftArgument_type > r (
          leftArgument_traits::create (i, f, this));

        this->leftArgument_.push_back (r);
        continue;
      }

      // rightArgument
      //
      if (n.name () == "rightArgument" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< rightArgument_type > r (
          rightArgument_traits::create (i, f, this));

        this->rightArgument_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "operator" && n.namespace_ ().empty ())
      {
        this->operator__.set (operator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  guard* guard::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class guard (*this, f, c);
  }

  guard& guard::
  operator= (const guard& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->leftArgument_ = x.leftArgument_;
      this->rightArgument_ = x.rightArgument_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->operator__ = x.operator__;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  guard::
  ~guard ()
  {
  }

  // states
  //

  states::
  states (const id_type& id,
          const name_type& name)
  : ::xml_schema::type (),
    duringActions_ (this),
    outerTransitions_ (this),
    type_ (this),
    id_ (id, this),
    executionOrder_ (this),
    externalID_ (this),
    isFixedName_ (this),
    machineType_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this),
    type1_ (this)
  {
  }

  states::
  states (const states& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    duringActions_ (x.duringActions_, f, this),
    outerTransitions_ (x.outerTransitions_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    executionOrder_ (x.executionOrder_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    machineType_ (x.machineType_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this),
    type1_ (x.type1_, f, this)
  {
  }

  states::
  states (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    duringActions_ (this),
    outerTransitions_ (this),
    type_ (this),
    id_ (this),
    executionOrder_ (this),
    externalID_ (this),
    isFixedName_ (this),
    machineType_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this),
    type1_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void states::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // duringActions
      //
      if (n.name () == "duringActions" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< duringActions_type > r (
          duringActions_traits::create (i, f, this));

        this->duringActions_.push_back (r);
        continue;
      }

      // outerTransitions
      //
      if (n.name () == "outerTransitions" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< outerTransitions_type > r (
          outerTransitions_traits::create (i, f, this));

        this->outerTransitions_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "executionOrder" && n.namespace_ ().empty ())
      {
        this->executionOrder_.set (executionOrder_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "machineType" && n.namespace_ ().empty ())
      {
        this->machineType_.set (machineType_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type1_.set (type1_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  states* states::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class states (*this, f, c);
  }

  states& states::
  operator= (const states& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->duringActions_ = x.duringActions_;
      this->outerTransitions_ = x.outerTransitions_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->executionOrder_ = x.executionOrder_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->machineType_ = x.machineType_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceElementId_ = x.sourceElementId_;
      this->type1_ = x.type1_;
    }

    return *this;
  }

  states::
  ~states ()
  {
  }

  // duringActions
  //

  duringActions::
  duringActions (const id_type& id,
                 const name_type& name)
  : ::xml_schema::type (),
    operation_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this)
  {
  }

  duringActions::
  duringActions (const duringActions& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    operation_ (x.operation_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  duringActions::
  duringActions (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    operation_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void duringActions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // operation
      //
      if (n.name () == "operation" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< operation_type > r (
          operation_traits::create (i, f, this));

        this->operation_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  duringActions* duringActions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class duringActions (*this, f, c);
  }

  duringActions& duringActions::
  operator= (const duringActions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->operation_ = x.operation_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  duringActions::
  ~duringActions ()
  {
  }

  // operation
  //

  operation::
  operation (const id_type& id,
             const name_type& name)
  : ::xml_schema::type (),
    leftExpression_ (this),
    rightExpression_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    operator__ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    saturation_ (this),
    sequenceNumber_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
  }

  operation::
  operation (const operation& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    leftExpression_ (x.leftExpression_, f, this),
    rightExpression_ (x.rightExpression_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    operator__ (x.operator__, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    saturation_ (x.saturation_, f, this),
    sequenceNumber_ (x.sequenceNumber_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  operation::
  operation (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    leftExpression_ (this),
    rightExpression_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    operator__ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    saturation_ (this),
    sequenceNumber_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void operation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // leftExpression
      //
      if (n.name () == "leftExpression" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< leftExpression_type > r (
          leftExpression_traits::create (i, f, this));

        this->leftExpression_.push_back (r);
        continue;
      }

      // rightExpression
      //
      if (n.name () == "rightExpression" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< rightExpression_type > r (
          rightExpression_traits::create (i, f, this));

        this->rightExpression_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "operator" && n.namespace_ ().empty ())
      {
        this->operator__.set (operator_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "saturation" && n.namespace_ ().empty ())
      {
        this->saturation_.set (saturation_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sequenceNumber" && n.namespace_ ().empty ())
      {
        this->sequenceNumber_.set (sequenceNumber_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  operation* operation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class operation (*this, f, c);
  }

  operation& operation::
  operator= (const operation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->leftExpression_ = x.leftExpression_;
      this->rightExpression_ = x.rightExpression_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->operator__ = x.operator__;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->saturation_ = x.saturation_;
      this->sequenceNumber_ = x.sequenceNumber_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  operation::
  ~operation ()
  {
  }

  // sideExpression
  //

  sideExpression::
  sideExpression (const id_type& id,
                  const name_type& name)
  : ::xml_schema::type (),
    argument_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
  }

  sideExpression::
  sideExpression (const sideExpression& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    argument_ (x.argument_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  sideExpression::
  sideExpression (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    argument_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void sideExpression::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // argument
      //
      if (n.name () == "argument" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< argument_type > r (
          argument_traits::create (i, f, this));

        this->argument_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  sideExpression* sideExpression::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sideExpression (*this, f, c);
  }

  sideExpression& sideExpression::
  operator= (const sideExpression& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->argument_ = x.argument_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  sideExpression::
  ~sideExpression ()
  {
  }

  // outerTransitions
  //

  outerTransitions::
  outerTransitions (const id_type& id,
                    const name_type& name)
  : ::xml_schema::type (),
    guard_ (this),
    type_ (this),
    id_ (id, this),
    destination_ (this),
    executionOrder_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this),
    type1_ (this)
  {
  }

  outerTransitions::
  outerTransitions (const outerTransitions& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    guard_ (x.guard_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    destination_ (x.destination_, f, this),
    executionOrder_ (x.executionOrder_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this),
    type1_ (x.type1_, f, this)
  {
  }

  outerTransitions::
  outerTransitions (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    guard_ (this),
    type_ (this),
    id_ (this),
    destination_ (this),
    executionOrder_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this),
    type1_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void outerTransitions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // guard
      //
      if (n.name () == "guard" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< guard_type > r (
          guard_traits::create (i, f, this));

        this->guard_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "destination" && n.namespace_ ().empty ())
      {
        this->destination_.set (destination_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "executionOrder" && n.namespace_ ().empty ())
      {
        this->executionOrder_.set (executionOrder_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type1_.set (type1_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  outerTransitions* outerTransitions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class outerTransitions (*this, f, c);
  }

  outerTransitions& outerTransitions::
  operator= (const outerTransitions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->guard_ = x.guard_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->destination_ = x.destination_;
      this->executionOrder_ = x.executionOrder_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceElementId_ = x.sourceElementId_;
      this->type1_ = x.type1_;
    }

    return *this;
  }

  outerTransitions::
  ~outerTransitions ()
  {
  }

  // customTypes
  //

  customTypes::
  customTypes (const id_type& id,
               const name_type& name)
  : ::xml_schema::type (),
    members_ (this),
    type_ (this),
    id_ (id, this),
    alias_ (this),
    externalID_ (this),
    isFixedName_ (this),
    isUnion_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    scope_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
  }

  customTypes::
  customTypes (const customTypes& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    members_ (x.members_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    alias_ (x.alias_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    isUnion_ (x.isUnion_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    scope_ (x.scope_, f, this),
    sourceAction_ (x.sourceAction_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  customTypes::
  customTypes (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    members_ (this),
    type_ (this),
    id_ (this),
    alias_ (this),
    externalID_ (this),
    isFixedName_ (this),
    isUnion_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    scope_ (this),
    sourceAction_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void customTypes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // members
      //
      if (n.name () == "members" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< members_type > r (
          members_traits::create (i, f, this));

        this->members_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "alias" && n.namespace_ ().empty ())
      {
        this->alias_.set (alias_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isUnion" && n.namespace_ ().empty ())
      {
        this->isUnion_.set (isUnion_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (scope_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceAction" && n.namespace_ ().empty ())
      {
        this->sourceAction_.set (sourceAction_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  customTypes* customTypes::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class customTypes (*this, f, c);
  }

  customTypes& customTypes::
  operator= (const customTypes& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->members_ = x.members_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->alias_ = x.alias_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->isUnion_ = x.isUnion_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->scope_ = x.scope_;
      this->sourceAction_ = x.sourceAction_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  customTypes::
  ~customTypes ()
  {
  }

  // members
  //

  members::
  members (const id_type& id,
           const name_type& name)
  : ::xml_schema::type (),
    dataType_ (this),
    type_ (this),
    id_ (id, this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (name, this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this)
  {
  }

  members::
  members (const members& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dataType_ (x.dataType_, f, this),
    type_ (x.type_, f, this),
    id_ (x.id_, f, this),
    externalID_ (x.externalID_, f, this),
    isFixedName_ (x.isFixedName_, f, this),
    name_ (x.name_, f, this),
    originalFullName_ (x.originalFullName_, f, this),
    originalName_ (x.originalName_, f, this),
    referencedFullName_ (x.referencedFullName_, f, this),
    sourceElementId_ (x.sourceElementId_, f, this)
  {
  }

  members::
  members (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dataType_ (this),
    type_ (this),
    id_ (this),
    externalID_ (this),
    isFixedName_ (this),
    name_ (this),
    originalFullName_ (this),
    originalName_ (this),
    referencedFullName_ (this),
    sourceElementId_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void members::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dataType
      //
      if (n.name () == "dataType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< dataType_type > r (
          dataType_traits::create (i, f, this));

        this->dataType_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->type_.set (type_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ () == "http://schema.omg.org/spec/XMI/2.1")
      {
        this->id_.set (id_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "externalID" && n.namespace_ ().empty ())
      {
        this->externalID_.set (externalID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFixedName" && n.namespace_ ().empty ())
      {
        this->isFixedName_.set (isFixedName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (name_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalFullName" && n.namespace_ ().empty ())
      {
        this->originalFullName_.set (originalFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "originalName" && n.namespace_ ().empty ())
      {
        this->originalName_.set (originalName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "referencedFullName" && n.namespace_ ().empty ())
      {
        this->referencedFullName_.set (referencedFullName_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "sourceElementId" && n.namespace_ ().empty ())
      {
        this->sourceElementId_.set (sourceElementId_traits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "http://schema.omg.org/spec/XMI/2.1");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  members* members::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class members (*this, f, c);
  }

  members& members::
  operator= (const members& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->dataType_ = x.dataType_;
      this->type_ = x.type_;
      this->id_ = x.id_;
      this->externalID_ = x.externalID_;
      this->isFixedName_ = x.isFixedName_;
      this->name_ = x.name_;
      this->originalFullName_ = x.originalFullName_;
      this->originalName_ = x.originalName_;
      this->referencedFullName_ = x.referencedFullName_;
      this->sourceElementId_ = x.sourceElementId_;
    }

    return *this;
  }

  members::
  ~members ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace QGenXMI
{
  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::QGenXMI::model > (
      ::QGenXMI::GASystemModel (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::QGenXMI::model > (
      ::QGenXMI::GASystemModel (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::QGenXMI::model > (
      ::QGenXMI::GASystemModel (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::QGenXMI::GASystemModel (isrc, f, p);
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::QGenXMI::GASystemModel (isrc, h, f, p);
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::QGenXMI::GASystemModel (isrc, h, f, p);
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::QGenXMI::GASystemModel (isrc, f, p);
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::QGenXMI::GASystemModel (isrc, h, f, p);
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::QGenXMI::GASystemModel (isrc, h, f, p);
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::QGenXMI::model > (
      ::QGenXMI::GASystemModel (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::QGenXMI::model > (
      ::QGenXMI::GASystemModel (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::QGenXMI::model > (
      ::QGenXMI::GASystemModel (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::QGenXMI::model > (
        ::QGenXMI::GASystemModel (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GASystemModel" &&
        n.namespace_ () == "http:///geneauto/emf/models/gasystemmodel.ecore")
    {
      ::std::auto_ptr< ::QGenXMI::model > r (
        ::xsd::cxx::tree::traits< ::QGenXMI::model, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GASystemModel",
      "http:///geneauto/emf/models/gasystemmodel.ecore");
  }

  ::std::auto_ptr< ::QGenXMI::model >
  GASystemModel (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "GASystemModel" &&
        n.namespace_ () == "http:///geneauto/emf/models/gasystemmodel.ecore")
    {
      ::std::auto_ptr< ::QGenXMI::model > r (
        ::xsd::cxx::tree::traits< ::QGenXMI::model, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "GASystemModel",
      "http:///geneauto/emf/models/gasystemmodel.ecore");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace QGenXMI
{
  void
  operator<< (::xercesc::DOMElement& e, const id_list& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::int_, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const id_list& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::int_, char >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const id_list& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::int_, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const valuetype& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const valuetype& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const valuetype& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  GASystemModel (::std::ostream& o,
                 const ::QGenXMI::model& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::QGenXMI::GASystemModel (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GASystemModel (::std::ostream& o,
                 const ::QGenXMI::model& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::QGenXMI::GASystemModel (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GASystemModel (::std::ostream& o,
                 const ::QGenXMI::model& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::QGenXMI::GASystemModel (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GASystemModel (::xercesc::XMLFormatTarget& t,
                 const ::QGenXMI::model& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::QGenXMI::GASystemModel (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  GASystemModel (::xercesc::XMLFormatTarget& t,
                 const ::QGenXMI::model& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::QGenXMI::GASystemModel (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GASystemModel (::xercesc::XMLFormatTarget& t,
                 const ::QGenXMI::model& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::QGenXMI::GASystemModel (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  GASystemModel (::xercesc::DOMDocument& d,
                 const ::QGenXMI::model& s,
                 ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "GASystemModel" &&
        n.namespace_ () == "http:///geneauto/emf/models/gasystemmodel.ecore")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GASystemModel",
        "http:///geneauto/emf/models/gasystemmodel.ecore");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  GASystemModel (const ::QGenXMI::model& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "GASystemModel",
        "http:///geneauto/emf/models/gasystemmodel.ecore",
        m, f));

    ::QGenXMI::GASystemModel (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const model& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // elements
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "elements",
          e));

      s << i.elements ();
    }

    // orphans
    //
    for (model::orphans_const_iterator
         b (i.orphans ().begin ()), n (i.orphans ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "orphans",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // fixedStep
    //
    if (i.fixedStep ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fixedStep",
          e));

      a << *i.fixedStep ();
    }

    // lastId
    //
    if (i.lastId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "lastId",
          e));

      a << *i.lastId ();
    }

    // lastSavedBy
    //
    if (i.lastSavedBy ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "lastSavedBy",
          e));

      a << *i.lastSavedBy ();
    }

    // lastSavedOn
    //
    if (i.lastSavedOn ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "lastSavedOn",
          e));

      a << *i.lastSavedOn ();
    }

    // modelName
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "modelName",
          e));

      a << i.modelName ();
    }

    // modelVersion
    //
    if (i.modelVersion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "modelVersion",
          e));

      a << *i.modelVersion ();
    }

    // noNewId
    //
    if (i.noNewId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "noNewId",
          e));

      a << *i.noNewId ();
    }

    // taskingType
    //
    if (i.taskingType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "taskingType",
          e));

      a << *i.taskingType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const elements& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // blocks
    //
    for (elements::blocks_const_iterator
         b (i.blocks ().begin ()), n (i.blocks ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "blocks",
          e));

      s << *b;
    }

    // customTypes
    //
    for (elements::customTypes_const_iterator
         b (i.customTypes ().begin ()), n (i.customTypes ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "customTypes",
          e));

      s << *b;
    }

    // inDataPorts
    //
    for (elements::inDataPorts_const_iterator
         b (i.inDataPorts ().begin ()), n (i.inDataPorts ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inDataPorts",
          e));

      s << *b;
    }

    // outDataPorts
    //
    for (elements::outDataPorts_const_iterator
         b (i.outDataPorts ().begin ()), n (i.outDataPorts ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "outDataPorts",
          e));

      s << *b;
    }

    // signals
    //
    for (elements::signals_const_iterator
         b (i.signals ().begin ()), n (i.signals ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "signals",
          e));

      s << *b;
    }

    // variables
    //
    for (elements::variables_const_iterator
         b (i.variables ().begin ()), n (i.variables ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "variables",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // assignedPriority
    //
    if (i.assignedPriority ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "assignedPriority",
          e));

      a << *i.assignedPriority ();
    }

    // assignedPrioritySource
    //
    if (i.assignedPrioritySource ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "assignedPrioritySource",
          e));

      a << *i.assignedPrioritySource ();
    }

    // executionOrder
    //
    if (i.executionOrder ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "executionOrder",
          e));

      a << *i.executionOrder ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // fcnName
    //
    if (i.fcnName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fcnName",
          e));

      a << *i.fcnName ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // isFullyTyped
    //
    if (i.isFullyTyped ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFullyTyped",
          e));

      a << *i.isFullyTyped ();
    }

    // isReferenceModel
    //
    if (i.isReferenceModel ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isReferenceModel",
          e));

      a << *i.isReferenceModel ();
    }

    // maskType
    //
    if (i.maskType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maskType",
          e));

      a << *i.maskType ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // offset
    //
    if (i.offset ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "offset",
          e));

      a << *i.offset ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // samplePeriod
    //
    if (i.samplePeriod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "samplePeriod",
          e));

      a << *i.samplePeriod ();
    }

    // sourceBlockName
    //
    if (i.sourceBlockName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceBlockName",
          e));

      a << *i.sourceBlockName ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }

    // style
    //
    if (i.style ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "style",
          e));

      a << *i.style ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type1 ();
    }

    // userDefinedPriority
    //
    if (i.userDefinedPriority ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "userDefinedPriority",
          e));

      a << *i.userDefinedPriority ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const blocks& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // blocks
    //
    for (blocks::blocks1_const_iterator
         b (i.blocks1 ().begin ()), n (i.blocks1 ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "blocks",
          e));

      s << *b;
    }

    // inDataPorts
    //
    for (blocks::inDataPorts_const_iterator
         b (i.inDataPorts ().begin ()), n (i.inDataPorts ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inDataPorts",
          e));

      s << *b;
    }

    // inEdgeEnablePort
    //
    if (i.inEdgeEnablePort ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inEdgeEnablePort",
          e));

      s << *i.inEdgeEnablePort ();
    }

    // inEnablePort
    //
    if (i.inEnablePort ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inEnablePort",
          e));

      s << *i.inEnablePort ();
    }

    // outDataPorts
    //
    for (blocks::outDataPorts_const_iterator
         b (i.outDataPorts ().begin ()), n (i.outDataPorts ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "outDataPorts",
          e));

      s << *b;
    }

    // parameters
    //
    for (blocks::parameters_const_iterator
         b (i.parameters ().begin ()), n (i.parameters ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parameters",
          e));

      s << *b;
    }

    // signals
    //
    for (blocks::signals_const_iterator
         b (i.signals ().begin ()), n (i.signals ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "signals",
          e));

      s << *b;
    }

    // inControlPort
    //
    if (i.inControlPort ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "inControlPort",
          e));

      s << *i.inControlPort ();
    }

    // outControlPorts
    //
    for (blocks::outControlPorts_const_iterator
         b (i.outControlPorts ().begin ()), n (i.outControlPorts ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "outControlPorts",
          e));

      s << *b;
    }

    // composition
    //
    for (blocks::composition_const_iterator
         b (i.composition ().begin ()), n (i.composition ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "composition",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // assignedPriority
    //
    if (i.assignedPriority ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "assignedPriority",
          e));

      a << *i.assignedPriority ();
    }

    // assignedPrioritySource
    //
    if (i.assignedPrioritySource ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "assignedPrioritySource",
          e));

      a << *i.assignedPrioritySource ();
    }

    // executionOrder
    //
    if (i.executionOrder ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "executionOrder",
          e));

      a << *i.executionOrder ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // isFullyTyped
    //
    if (i.isFullyTyped ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFullyTyped",
          e));

      a << *i.isFullyTyped ();
    }

    // maskType
    //
    if (i.maskType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maskType",
          e));

      a << *i.maskType ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // offset
    //
    if (i.offset ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "offset",
          e));

      a << *i.offset ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // samplePeriod
    //
    if (i.samplePeriod ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "samplePeriod",
          e));

      a << *i.samplePeriod ();
    }

    // sourceBlockName
    //
    if (i.sourceBlockName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceBlockName",
          e));

      a << *i.sourceBlockName ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.type1 ();
    }

    // userDefinedPriority
    //
    if (i.userDefinedPriority ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "userDefinedPriority",
          e));

      a << *i.userDefinedPriority ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const inDataPorts& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // dataType
    //
    for (inDataPorts::dataType_const_iterator
         b (i.dataType ().begin ()), n (i.dataType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataType",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // incomingSignal
    //
    if (i.incomingSignal ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "incomingSignal",
          e));

      a << *i.incomingSignal ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // isRequiredBySuccessors
    //
    if (i.isRequiredBySuccessors ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isRequiredBySuccessors",
          e));

      a << *i.isRequiredBySuccessors ();
    }

    // isVirtual
    //
    if (i.isVirtual ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isVirtual",
          e));

      a << *i.isVirtual ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // periodicSampleTime
    //
    if (i.periodicSampleTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "periodicSampleTime",
          e));

      a << *i.periodicSampleTime ();
    }

    // portNumber
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "portNumber",
          e));

      a << i.portNumber ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sampleTime
    //
    if (i.sampleTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sampleTime",
          e));

      a << *i.sampleTime ();
    }

    // sourceBlock
    //
    if (i.sourceBlock ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceBlock",
          e));

      a << *i.sourceBlock ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }

    // statesWhenEnabling
    //
    if (i.statesWhenEnabling ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "statesWhenEnabling",
          e));

      a << *i.statesWhenEnabling ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const outDataPorts& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // dataType
    //
    for (outDataPorts::dataType_const_iterator
         b (i.dataType ().begin ()), n (i.dataType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataType",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // isVirtual
    //
    if (i.isVirtual ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isVirtual",
          e));

      a << *i.isVirtual ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // outgoingSignals
    //
    if (i.outgoingSignals ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "outgoingSignals",
          e));

      a << *i.outgoingSignals ();
    }

    // portNumber
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "portNumber",
          e));

      a << i.portNumber ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // resetWhenDisabled
    //
    if (i.resetWhenDisabled ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "resetWhenDisabled",
          e));

      a << *i.resetWhenDisabled ();
    }

    // sourceBlock
    //
    if (i.sourceBlock ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceBlock",
          e));

      a << *i.sourceBlock ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const dataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // initialValue
    //
    for (dataType::initialValue_const_iterator
         b (i.initialValue ().begin ()), n (i.initialValue ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "initialValue",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // scope
    //
    if (i.scope ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scope",
          e));

      a << *i.scope ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const initialValue& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // valueDataType
    //
    for (initialValue::valueDataType_const_iterator
         b (i.valueDataType ().begin ()), n (i.valueDataType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "valueDataType",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // litValue
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "litValue",
          e));

      a << i.litValue ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const valueDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // scope
    //
    if (i.scope ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scope",
          e));

      a << *i.scope ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const parameters& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // value
    //
    for (parameters::value_const_iterator
         b (i.value ().begin ()), n (i.value ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // index
    //
    if (i.index ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "index",
          e));

      a << *i.index ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // isMask
    //
    if (i.isMask ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isMask",
          e));

      a << *i.isMask ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // scope
    //
    if (i.scope ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scope",
          e));

      a << *i.scope ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }

    // storageClass
    //
    if (i.storageClass ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "storageClass",
          e));

      a << *i.storageClass ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const value& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // argument
    //
    for (value::argument_const_iterator
         b (i.argument ().begin ()), n (i.argument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          e));

      s << *b;
    }

    // valueDataType
    //
    for (value::valueDataType_const_iterator
         b (i.valueDataType ().begin ()), n (i.valueDataType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "valueDataType",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // litValue
    //
    if (i.litValue ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "litValue",
          e));

      a << *i.litValue ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // operator
    //
    if (i.operator_ ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "operator",
          e));

      a << *i.operator_ ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElement
    //
    if (i.sourceElement ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElement",
          e));

      a << *i.sourceElement ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const argument& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // valueDataType
    //
    for (argument::valueDataType_const_iterator
         b (i.valueDataType ().begin ()), n (i.valueDataType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "valueDataType",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // litValue
    //
    if (i.litValue ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "litValue",
          e));

      a << *i.litValue ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // operator
    //
    if (i.operator_ ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "operator",
          e));

      a << *i.operator_ ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const signals& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // dstPort
    //
    if (i.dstPort ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "dstPort",
          e));

      a << *i.dstPort ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sampleTime
    //
    if (i.sampleTime ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sampleTime",
          e));

      a << *i.sampleTime ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }

    // srcPort
    //
    if (i.srcPort ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "srcPort",
          e));

      a << *i.srcPort ();
    }

    // storageClass
    //
    if (i.storageClass ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "storageClass",
          e));

      a << *i.storageClass ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const variables& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // dataType
    //
    for (variables::dataType_const_iterator
         b (i.dataType ().begin ()), n (i.dataType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataType",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // autoInit
    //
    if (i.autoInit ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "autoInit",
          e));

      a << *i.autoInit ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isConst
    //
    if (i.isConst ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isConst",
          e));

      a << *i.isConst ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // isIterator
    //
    if (i.isIterator ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isIterator",
          e));

      a << *i.isIterator ();
    }

    // isOptimizable
    //
    if (i.isOptimizable ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isOptimizable",
          e));

      a << *i.isOptimizable ();
    }

    // isSignalObject
    //
    if (i.isSignalObject ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isSignalObject",
          e));

      a << *i.isSignalObject ();
    }

    // isStatic
    //
    if (i.isStatic ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isStatic",
          e));

      a << *i.isStatic ();
    }

    // isUnreferenced
    //
    if (i.isUnreferenced ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isUnreferenced",
          e));

      a << *i.isUnreferenced ();
    }

    // isVolatile
    //
    if (i.isVolatile ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isVolatile",
          e));

      a << *i.isVolatile ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referenceBy
    //
    if (i.referenceBy ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referenceBy",
          e));

      a << *i.referenceBy ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // scope
    //
    if (i.scope ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scope",
          e));

      a << *i.scope ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const orphans& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // valueDataType
    //
    for (orphans::valueDataType_const_iterator
         b (i.valueDataType ().begin ()), n (i.valueDataType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "valueDataType",
          e));

      s << *b;
    }

    // argument
    //
    for (orphans::argument_const_iterator
         b (i.argument ().begin ()), n (i.argument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // litValue
    //
    if (i.litValue ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "litValue",
          e));

      a << *i.litValue ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // operator
    //
    if (i.operator_ ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "operator",
          e));

      a << *i.operator_ ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }

    // variable
    //
    if (i.variable ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "variable",
          e));

      a << *i.variable ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const sideArgument& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // expresion
    //
    for (sideArgument::expresion_const_iterator
         b (i.expresion ().begin ()), n (i.expresion ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "expresion",
          e));

      s << *b;
    }

    // valueDataType
    //
    for (sideArgument::valueDataType_const_iterator
         b (i.valueDataType ().begin ()), n (i.valueDataType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "valueDataType",
          e));

      s << *b;
    }

    // arguments
    //
    for (sideArgument::arguments_const_iterator
         b (i.arguments ().begin ()), n (i.arguments ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "arguments",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }

    // standardFunction
    //
    if (i.standardFunction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "standardFunction",
          e));

      a << *i.standardFunction ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const expression& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // leftArgument
    //
    for (expression::leftArgument_const_iterator
         b (i.leftArgument ().begin ()), n (i.leftArgument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "leftArgument",
          e));

      s << *b;
    }

    // rightArgument
    //
    for (expression::rightArgument_const_iterator
         b (i.rightArgument ().begin ()), n (i.rightArgument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rightArgument",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // operator
    //
    if (i.operator_ ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "operator",
          e));

      a << *i.operator_ ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const composition& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // defaultTransitions
    //
    for (composition::defaultTransitions_const_iterator
         b (i.defaultTransitions ().begin ()), n (i.defaultTransitions ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "defaultTransitions",
          e));

      s << *b;
    }

    // junctions
    //
    for (composition::junctions_const_iterator
         b (i.junctions ().begin ()), n (i.junctions ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "junctions",
          e));

      s << *b;
    }

    // states
    //
    for (composition::states_const_iterator
         b (i.states ().begin ()), n (i.states ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "states",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const defaultTransitions& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // destination
    //
    if (i.destination ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "destination",
          e));

      a << *i.destination ();
    }

    // executionOrder
    //
    if (i.executionOrder ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "executionOrder",
          e));

      a << *i.executionOrder ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }

    // type
    //
    if (i.type1 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.type1 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const junctions& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // transitions
    //
    for (junctions::transitions_const_iterator
         b (i.transitions ().begin ()), n (i.transitions ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "transitions",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // junctionType
    //
    if (i.junctionType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "junctionType",
          e));

      a << *i.junctionType ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const transitions& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // guard
    //
    for (transitions::guard_const_iterator
         b (i.guard ().begin ()), n (i.guard ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "guard",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // destination
    //
    if (i.destination ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "destination",
          e));

      a << *i.destination ();
    }

    // executionOrder
    //
    if (i.executionOrder ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "executionOrder",
          e));

      a << *i.executionOrder ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }

    // type
    //
    if (i.type1 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.type1 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const guard& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // leftArgument
    //
    for (guard::leftArgument_const_iterator
         b (i.leftArgument ().begin ()), n (i.leftArgument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "leftArgument",
          e));

      s << *b;
    }

    // rightArgument
    //
    for (guard::rightArgument_const_iterator
         b (i.rightArgument ().begin ()), n (i.rightArgument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rightArgument",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // operator
    //
    if (i.operator_ ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "operator",
          e));

      a << *i.operator_ ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const states& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // duringActions
    //
    for (states::duringActions_const_iterator
         b (i.duringActions ().begin ()), n (i.duringActions ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "duringActions",
          e));

      s << *b;
    }

    // outerTransitions
    //
    for (states::outerTransitions_const_iterator
         b (i.outerTransitions ().begin ()), n (i.outerTransitions ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "outerTransitions",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // executionOrder
    //
    if (i.executionOrder ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "executionOrder",
          e));

      a << *i.executionOrder ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // machineType
    //
    if (i.machineType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "machineType",
          e));

      a << *i.machineType ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }

    // type
    //
    if (i.type1 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.type1 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const duringActions& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // operation
    //
    for (duringActions::operation_const_iterator
         b (i.operation ().begin ()), n (i.operation ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "operation",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const operation& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // leftExpression
    //
    for (operation::leftExpression_const_iterator
         b (i.leftExpression ().begin ()), n (i.leftExpression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "leftExpression",
          e));

      s << *b;
    }

    // rightExpression
    //
    for (operation::rightExpression_const_iterator
         b (i.rightExpression ().begin ()), n (i.rightExpression ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "rightExpression",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // operator
    //
    if (i.operator_ ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "operator",
          e));

      a << *i.operator_ ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // saturation
    //
    if (i.saturation ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "saturation",
          e));

      a << *i.saturation ();
    }

    // sequenceNumber
    //
    if (i.sequenceNumber ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sequenceNumber",
          e));

      a << *i.sequenceNumber ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const sideExpression& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // argument
    //
    for (sideExpression::argument_const_iterator
         b (i.argument ().begin ()), n (i.argument ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "argument",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const outerTransitions& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // guard
    //
    for (outerTransitions::guard_const_iterator
         b (i.guard ().begin ()), n (i.guard ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "guard",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // destination
    //
    if (i.destination ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "destination",
          e));

      a << *i.destination ();
    }

    // executionOrder
    //
    if (i.executionOrder ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "executionOrder",
          e));

      a << *i.executionOrder ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }

    // type
    //
    if (i.type1 ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << *i.type1 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const customTypes& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // members
    //
    for (customTypes::members_const_iterator
         b (i.members ().begin ()), n (i.members ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "members",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // alias
    //
    if (i.alias ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "alias",
          e));

      a << *i.alias ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // isUnion
    //
    if (i.isUnion ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isUnion",
          e));

      a << *i.isUnion ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // scope
    //
    if (i.scope ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scope",
          e));

      a << *i.scope ();
    }

    // sourceAction
    //
    if (i.sourceAction ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceAction",
          e));

      a << *i.sourceAction ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const members& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // dataType
    //
    for (members::dataType_const_iterator
         b (i.dataType ().begin ()), n (i.dataType ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dataType",
          e));

      s << *b;
    }

    // type
    //
    if (i.type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << *i.type ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          "http://schema.omg.org/spec/XMI/2.1",
          e));

      a << i.id ();
    }

    // externalID
    //
    if (i.externalID ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "externalID",
          e));

      a << *i.externalID ();
    }

    // isFixedName
    //
    if (i.isFixedName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFixedName",
          e));

      a << *i.isFixedName ();
    }

    // name
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << i.name ();
    }

    // originalFullName
    //
    if (i.originalFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalFullName",
          e));

      a << *i.originalFullName ();
    }

    // originalName
    //
    if (i.originalName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "originalName",
          e));

      a << *i.originalName ();
    }

    // referencedFullName
    //
    if (i.referencedFullName ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "referencedFullName",
          e));

      a << *i.referencedFullName ();
    }

    // sourceElementId
    //
    if (i.sourceElementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "sourceElementId",
          e));

      a << *i.sourceElementId ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

